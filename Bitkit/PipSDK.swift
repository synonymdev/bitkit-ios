//
//  PipSDK.swift
//  Bitkit iOS Native Bridge for PIP SDK
//
//  Integrates pip-uniffi Rust library with React Native
//

import Foundation
import PipUniFFI // Generated by UniFFI from pip.udl

@objc(PipSDK)
class PipSDK: RCTEventEmitter {
    
    private var activeSessions: [String: Arc<PipSessionHandle>] = [:]
    private var config: PipConfig?
    private var sessionStore: PipSessionStore?
    private var backgroundHandler: PipBackgroundHandler?
    
    override init() {
        super.init()
        
        // Listen for background webhook events
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(handleBackgroundWebhook(_:)),
            name: .pipWebhookProcessed,
            object: nil
        )
    }
    
    // MARK: - Event Emitter
    
    override static func requiresMainQueueSetup() -> Bool {
        return false
    }
    
    override func supportedEvents() -> [String]! {
        return [
            "PipQuoteReady",
            "PipPreimageReceived",
            "PipTxBroadcast",
            "PipTxConfirmed",
            "PipSwept",
            "PipError"
        ]
    }
    
    // MARK: - Public API
    
    @objc
    func requestQuote(_ request: NSDictionary, resolver resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) {
        
        Task {
            do {
                // Parse request
                guard let receiverUrls = request["receiver_urls"] as? [String],
                      let amountSat = request["amount_sat"] as? UInt64,
                      let destinationAddress = request["destination_address"] as? String,
                      let configDict = request["config"] as? NSDictionary else {
                    reject("INVALID_PARAMS", "Invalid request parameters", nil)
                    return
                }
                
                // Build config
                let pipConfig = try self.buildConfig(from: configDict)
                self.config = pipConfig
                
                // Initialize session store and background handler
                if sessionStore == nil {
                    sessionStore = PipSessionStore(config: pipConfig)
                    backgroundHandler = PipBackgroundHandler.shared
                    backgroundHandler?.initialize(config: pipConfig)
                }
                
                // Build capabilities
                let capabilities = self.buildCapabilities(from: request["capabilities"] as? NSDictionary)
                
                // Convert destination address to scriptPubkey
                let merchantSpk = try self.addressToScriptPubkey(destinationAddress)
                
                // Call pip_receive_ln_to_onchain
                let session = try await pipReceiveLnToOnchain(
                    receiverUrls: receiverUrls,
                    amountSat: amountSat,
                    merchantSpk: merchantSpk,
                    capabilities: capabilities,
                    config: pipConfig
                )
                
                // Store session
                let quoteId = session.quoteId()
                self.activeSessions[quoteId] = session
                
                // Persist session for background access
                await sessionStore?.saveSessionData(
                    quoteId: quoteId,
                    session: session,
                    receiverUrl: receiverUrls[0]
                )
                
                // Start background monitoring
                self.monitorSession(quoteId: quoteId, session: session)
                
                // Emit quote ready event
                self.sendEvent(
                    withName: "PipQuoteReady",
                    body: [
                        "quote_id": quoteId,
                        "invoice": session.invoiceBolt11(),
                        "payment_hash": session.paymentHashHex(),
                        "amount_sat": amountSat
                    ]
                )
                
                // Return session data
                resolve([
                    "quote_id": quoteId,
                    "invoice": session.invoiceBolt11(),
                    "payment_hash": session.paymentHashHex(),
                    "amount_sat": amountSat,
                    "status": self.statusToString(session.status())
                ])
                
            } catch {
                reject("PIP_ERROR", error.localizedDescription, error)
            }
        }
    }
    
    @objc
    private func handleBackgroundWebhook(_ notification: Notification) {
        guard let quoteId = notification.userInfo?["quote_id"] as? String,
              let statusString = notification.userInfo?["status"] as? String else {
            return
        }
        
        print("[PipSDK] Background webhook processed for \(quoteId), status: \(statusString)")
        
        // Emit status update to React Native
        sendEvent(
            withName: "PipStatusUpdate",
            body: [
                "quote_id": quoteId,
                "status": statusString
            ]
        )
        
        // If we have the session in memory, emit detailed event
        if let session = activeSessions[quoteId] {
            let status = session.status()
            handleStatusChange(quoteId: quoteId, status: status)
        }
    }
    
    @objc
    func getSessionStatus(_ quoteId: String, resolver resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) {
        
        guard let session = activeSessions[quoteId] else {
            reject("SESSION_NOT_FOUND", "No session found for quote_id: \(quoteId)", nil)
            return
        }
        
        let status = session.status()
        resolve([
            "quote_id": quoteId,
            "invoice": session.invoiceBolt11(),
            "payment_hash": session.paymentHashHex(),
            "status": self.statusToString(status),
            "txid": self.extractTxid(from: status)
        ])
    }
    
    @objc
    func cancelSession(_ quoteId: String, resolver resolve: @escaping RCTPromiseResolveBlock, rejecter reject: @escaping RCTPromiseRejectBlock) {
        
        guard let session = activeSessions[quoteId] else {
            reject("SESSION_NOT_FOUND", "No session found for quote_id: \(quoteId)", nil)
            return
        }
        
        do {
            try session.cancel()
            activeSessions.removeValue(forKey: quoteId)
            resolve(nil)
        } catch {
            reject("CANCEL_ERROR", error.localizedDescription, error)
        }
    }
    
    // MARK: - Background Monitoring
    
    private func monitorSession(quoteId: String, session: Arc<PipSessionHandle>) {
        Task {
            var lastStatus: PipStatus? = nil
            
            while true {
                guard activeSessions[quoteId] != nil else {
                    // Session was cancelled
                    break
                }
                
                let currentStatus = session.status()
                
                // Check if status changed
                if !self.statusEquals(lastStatus, currentStatus) {
                    lastStatus = currentStatus
                    self.handleStatusChange(quoteId: quoteId, status: currentStatus)
                    
                    // Stop monitoring if final state reached
                    if self.isFinalStatus(currentStatus) {
                        break
                    }
                }
                
                // Poll every 2 seconds
                try? await Task.sleep(nanoseconds: 2_000_000_000)
            }
        }
    }
    
    private func handleStatusChange(quoteId: String, status: PipStatus) {
        switch status {
        case .preimageReceived(let source):
            sendEvent(
                withName: "PipPreimageReceived",
                body: [
                    "quote_id": quoteId,
                    "source": source == .webhook ? "webhook" : "par"
                ]
            )
            
        case .broadcasted(let txid):
            sendEvent(
                withName: "PipTxBroadcast",
                body: [
                    "quote_id": quoteId,
                    "txid": txid
                ]
            )
            
        case .confirmed(let height):
            sendEvent(
                withName: "PipTxConfirmed",
                body: [
                    "quote_id": quoteId,
                    "height": height
                ]
            )
            
        case .swept(let txid):
            sendEvent(
                withName: "PipSwept",
                body: [
                    "quote_id": quoteId,
                    "txid": txid
                ]
            )
            
        case .failed(let reason):
            sendEvent(
                withName: "PipError",
                body: [
                    "quote_id": quoteId,
                    "error": reason
                ]
            )
            
        default:
            break
        }
    }
    
    // MARK: - Helper Methods
    
    private func buildConfig(from dict: NSDictionary) throws -> PipConfig {
        guard let stateDir = dict["state_dir"] as? String,
              let esploraUrls = dict["esplora_urls"] as? [String],
              let useTor = dict["use_tor"] as? Bool,
              let webhookHmacKey = dict["webhook_hmac_key"] as? String,
              let tofuMode = dict["tofu_mode"] as? String else {
            throw NSError(domain: "PipSDK", code: -1, userInfo: [NSLocalizedDescriptionKey: "Invalid config"])
        }
        
        // Convert hex webhook key to bytes
        let hmacKeyData = Data(hexString: webhookHmacKey) ?? Data(count: 32)
        
        return PipConfig(
            stateDir: stateDir,
            esploraUrls: esploraUrls,
            useTor: useTor,
            webhookHmacKey: [UInt8](hmacKeyData),
            tofuMode: tofuMode
        )
    }
    
    private func buildCapabilities(from dict: NSDictionary?) -> PipCapabilities? {
        guard let dict = dict else {
            return PipCapabilities(
                parSupported: true,
                hashlockSupported: true,
                adaptorSupported: false,
                reservationSupported: true,
                packageRelayAssumed: false
            )
        }
        
        return PipCapabilities(
            parSupported: dict["par_supported"] as? Bool ?? true,
            hashlockSupported: dict["hashlock_supported"] as? Bool ?? true,
            adaptorSupported: dict["adaptor_supported"] as? Bool ?? false,
            reservationSupported: dict["reservation_supported"] as? Bool ?? true,
            packageRelayAssumed: dict["package_relay_assumed"] as? Bool ?? false
        )
    }
    
    private func addressToScriptPubkey(_ address: String) throws -> String {
        // Note: Address parsing is handled by the UniFFI wrapper's parse_address_to_scriptpubkey()
        // which is called internally by pip_receive_ln_to_onchain(). This function just passes
        // the address through - no conversion needed at the mobile layer.
        return address
    }
    
    private func statusToString(_ status: PipStatus) -> String {
        switch status {
        case .quoted: return "Quoted"
        case .invoicePresented: return "InvoicePresented"
        case .waitingPreimage: return "WaitingPreimage"
        case .preimageReceived: return "PreimageReceived"
        case .broadcasted: return "Broadcasted"
        case .confirmed: return "Confirmed"
        case .swept: return "Swept"
        case .failed: return "Failed"
        }
    }
    
    private func extractTxid(from status: PipStatus) -> String? {
        switch status {
        case .broadcasted(let txid), .swept(let txid):
            return txid
        default:
            return nil
        }
    }
    
    private func statusEquals(_ a: PipStatus?, _ b: PipStatus) -> Bool {
        guard let a = a else { return false }
        return statusToString(a) == statusToString(b)
    }
    
    private func isFinalStatus(_ status: PipStatus) -> Bool {
        switch status {
        case .confirmed, .swept, .failed:
            return true
        default:
            return false
        }
    }
}

// MARK: - Data Extension

extension Data {
    init?(hexString: String) {
        let len = hexString.count / 2
        var data = Data(capacity: len)
        var i = hexString.startIndex
        for _ in 0..<len {
            let j = hexString.index(i, offsetBy: 2)
            let bytes = hexString[i..<j]
            if var num = UInt8(bytes, radix: 16) {
                data.append(&num, count: 1)
            } else {
                return nil
            }
            i = j
        }
        self = data
    }
}
