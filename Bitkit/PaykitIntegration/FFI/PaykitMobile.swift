// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(paykit_mobileFFI)
import paykit_mobileFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_paykit_mobile_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_paykit_mobile_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsurePaykitMobileInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate final class UniffiHandleMap<T>: @unchecked Sendable {
    // All mutation happens with this lock held, which is why we implement @unchecked Sendable.
    private let lock = NSLock()
    private var map: [UInt64: T] = [:]
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.
// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}




/**
 * FFI wrapper for authenticated transport operations.
 *
 * This wraps authenticated write access to Pubky homeservers.
 * Mobile apps can use either:
 * - `new_mock()` for testing
 * - `from_callback()` for production with real Pubky SDK
 */
public protocol AuthenticatedTransportFfiProtocol: AnyObject, Sendable {
    
    /**
     * Delete a file at the given path.
     */
    func delete(path: String) throws 
    
    /**
     * Get a file at the given path.
     */
    func get(path: String) throws  -> String?
    
    /**
     * Check if this transport uses a real callback (production) or mock storage.
     *
     * Returns `true` for mock transport, `false` for callback-based transport.
     * Returns an error if the internal lock is poisoned.
     */
    func isMock() throws  -> Bool
    
    /**
     * List files with a given prefix.
     */
    func list(prefix: String) throws  -> [String]
    
    /**
     * Get the owner's public key.
     */
    func ownerPubkey()  -> String
    
    /**
     * Put (create or update) a file at the given path.
     */
    func put(path: String, content: String) throws 
    
}
/**
 * FFI wrapper for authenticated transport operations.
 *
 * This wraps authenticated write access to Pubky homeservers.
 * Mobile apps can use either:
 * - `new_mock()` for testing
 * - `from_callback()` for production with real Pubky SDK
 */
open class AuthenticatedTransportFfi: AuthenticatedTransportFfiProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_paykit_mobile_fn_clone_authenticatedtransportffi(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_paykit_mobile_fn_free_authenticatedtransportffi(pointer, $0) }
    }

    
    /**
     * Create authenticated transport from a storage callback.
     *
     * # Arguments
     *
     * * `callback` - Storage callback implementing PubkyAuthenticatedStorageCallback
     * * `owner_pubkey` - The owner's public key (z-base32 encoded)
     *
     * # Example (Swift)
     *
     * ```swift
     * class MyPubkyStorage: PubkyAuthenticatedStorageCallback {
     * let session: PubkySession
     *
     * func put(path: String, content: String) -> StorageOperationResult {
     * do {
     * try session.storage.put(path, content)
     * return StorageOperationResult.ok()
     * } catch {
     * return StorageOperationResult.err(error.localizedDescription)
     * }
     * }
     * // ... implement other methods
     * }
     *
     * let transport = AuthenticatedTransportFFI.fromCallback(
     * MyPubkyStorage(session: session),
     * ownerPubkey: myPublicKey
     * )
     * ```
     */
public static func fromCallback(callback: PubkyAuthenticatedStorageCallback, ownerPubkey: String) -> AuthenticatedTransportFfi  {
    return try!  FfiConverterTypeAuthenticatedTransportFFI_lift(try! rustCall() {
    uniffi_paykit_mobile_fn_constructor_authenticatedtransportffi_from_callback(
        FfiConverterCallbackInterfacePubkyAuthenticatedStorageCallback_lower(callback),
        FfiConverterString.lower(ownerPubkey),$0
    )
})
}
    
    /**
     * Create authenticated transport from a Pubky session JSON.
     *
     * # Deprecated
     *
     * This method creates a mock transport. Use `from_callback()` for production.
     *
     * # Arguments
     *
     * * `session_json` - JSON configuration (validated but not used)
     * * `owner_pubkey` - The owner's public key (z-base32 encoded)
     */
public static func fromSessionJson(sessionJson: String, ownerPubkey: String)throws  -> AuthenticatedTransportFfi  {
    return try  FfiConverterTypeAuthenticatedTransportFFI_lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_constructor_authenticatedtransportffi_from_session_json(
        FfiConverterString.lower(sessionJson),
        FfiConverterString.lower(ownerPubkey),$0
    )
})
}
    
    /**
     * Create a new authenticated transport for testing/development.
     *
     * Uses in-memory storage - data is not persisted.
     *
     * # Arguments
     *
     * * `owner_pubkey` - The owner's public key (z-base32 encoded)
     */
public static func newMock(ownerPubkey: String) -> AuthenticatedTransportFfi  {
    return try!  FfiConverterTypeAuthenticatedTransportFFI_lift(try! rustCall() {
    uniffi_paykit_mobile_fn_constructor_authenticatedtransportffi_new_mock(
        FfiConverterString.lower(ownerPubkey),$0
    )
})
}
    

    
    /**
     * Delete a file at the given path.
     */
open func delete(path: String)throws   {try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_authenticatedtransportffi_delete(self.uniffiClonePointer(),
        FfiConverterString.lower(path),$0
    )
}
}
    
    /**
     * Get a file at the given path.
     */
open func get(path: String)throws  -> String?  {
    return try  FfiConverterOptionString.lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_authenticatedtransportffi_get(self.uniffiClonePointer(),
        FfiConverterString.lower(path),$0
    )
})
}
    
    /**
     * Check if this transport uses a real callback (production) or mock storage.
     *
     * Returns `true` for mock transport, `false` for callback-based transport.
     * Returns an error if the internal lock is poisoned.
     */
open func isMock()throws  -> Bool  {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_authenticatedtransportffi_is_mock(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * List files with a given prefix.
     */
open func list(prefix: String)throws  -> [String]  {
    return try  FfiConverterSequenceString.lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_authenticatedtransportffi_list(self.uniffiClonePointer(),
        FfiConverterString.lower(prefix),$0
    )
})
}
    
    /**
     * Get the owner's public key.
     */
open func ownerPubkey() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_paykit_mobile_fn_method_authenticatedtransportffi_owner_pubkey(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Put (create or update) a file at the given path.
     */
open func put(path: String, content: String)throws   {try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_authenticatedtransportffi_put(self.uniffiClonePointer(),
        FfiConverterString.lower(path),
        FfiConverterString.lower(content),$0
    )
}
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAuthenticatedTransportFFI: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AuthenticatedTransportFfi

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AuthenticatedTransportFfi {
        return AuthenticatedTransportFfi(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AuthenticatedTransportFfi) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthenticatedTransportFfi {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AuthenticatedTransportFfi, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthenticatedTransportFFI_lift(_ pointer: UnsafeMutableRawPointer) throws -> AuthenticatedTransportFfi {
    return try FfiConverterTypeAuthenticatedTransportFFI.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthenticatedTransportFFI_lower(_ value: AuthenticatedTransportFfi) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAuthenticatedTransportFFI.lower(value)
}






/**
 * FFI-safe wrapper for local contact cache.
 */
public protocol ContactCacheFfiProtocol: AnyObject, Sendable {
    
    /**
     * Add a contact by public key.
     */
    func add(pubkey: String) throws 
    
    /**
     * Add a contact with a display name.
     */
    func addWithName(pubkey: String, name: String) throws 
    
    /**
     * Clear all cached contacts.
     */
    func clear() throws 
    
    /**
     * Check if a contact exists.
     */
    func contains(pubkey: String) throws  -> Bool
    
    /**
     * Get the number of cached contacts.
     */
    func count() throws  -> UInt32
    
    /**
     * Get a specific contact by public key.
     */
    func get(pubkey: String) throws  -> CachedContactFfi?
    
    /**
     * Get all cached contacts.
     */
    func getAll() throws  -> [CachedContactFfi]
    
    /**
     * Remove a contact by public key.
     */
    func remove(pubkey: String) throws 
    
    /**
     * Sync with remote contacts.
     */
    func sync(remotePubkeys: [String]) throws  -> SyncResultFfi
    
}
/**
 * FFI-safe wrapper for local contact cache.
 */
open class ContactCacheFfi: ContactCacheFfiProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_paykit_mobile_fn_clone_contactcacheffi(self.pointer, $0) }
    }
    /**
     * Create a new contact cache (uses in-memory storage).
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_paykit_mobile_fn_constructor_contactcacheffi_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_paykit_mobile_fn_free_contactcacheffi(pointer, $0) }
    }

    

    
    /**
     * Add a contact by public key.
     */
open func add(pubkey: String)throws   {try rustCallWithError(FfiConverterTypeStorageCacheError_lift) {
    uniffi_paykit_mobile_fn_method_contactcacheffi_add(self.uniffiClonePointer(),
        FfiConverterString.lower(pubkey),$0
    )
}
}
    
    /**
     * Add a contact with a display name.
     */
open func addWithName(pubkey: String, name: String)throws   {try rustCallWithError(FfiConverterTypeStorageCacheError_lift) {
    uniffi_paykit_mobile_fn_method_contactcacheffi_add_with_name(self.uniffiClonePointer(),
        FfiConverterString.lower(pubkey),
        FfiConverterString.lower(name),$0
    )
}
}
    
    /**
     * Clear all cached contacts.
     */
open func clear()throws   {try rustCallWithError(FfiConverterTypeStorageCacheError_lift) {
    uniffi_paykit_mobile_fn_method_contactcacheffi_clear(self.uniffiClonePointer(),$0
    )
}
}
    
    /**
     * Check if a contact exists.
     */
open func contains(pubkey: String)throws  -> Bool  {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeStorageCacheError_lift) {
    uniffi_paykit_mobile_fn_method_contactcacheffi_contains(self.uniffiClonePointer(),
        FfiConverterString.lower(pubkey),$0
    )
})
}
    
    /**
     * Get the number of cached contacts.
     */
open func count()throws  -> UInt32  {
    return try  FfiConverterUInt32.lift(try rustCallWithError(FfiConverterTypeStorageCacheError_lift) {
    uniffi_paykit_mobile_fn_method_contactcacheffi_count(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get a specific contact by public key.
     */
open func get(pubkey: String)throws  -> CachedContactFfi?  {
    return try  FfiConverterOptionTypeCachedContactFFI.lift(try rustCallWithError(FfiConverterTypeStorageCacheError_lift) {
    uniffi_paykit_mobile_fn_method_contactcacheffi_get(self.uniffiClonePointer(),
        FfiConverterString.lower(pubkey),$0
    )
})
}
    
    /**
     * Get all cached contacts.
     */
open func getAll()throws  -> [CachedContactFfi]  {
    return try  FfiConverterSequenceTypeCachedContactFFI.lift(try rustCallWithError(FfiConverterTypeStorageCacheError_lift) {
    uniffi_paykit_mobile_fn_method_contactcacheffi_get_all(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Remove a contact by public key.
     */
open func remove(pubkey: String)throws   {try rustCallWithError(FfiConverterTypeStorageCacheError_lift) {
    uniffi_paykit_mobile_fn_method_contactcacheffi_remove(self.uniffiClonePointer(),
        FfiConverterString.lower(pubkey),$0
    )
}
}
    
    /**
     * Sync with remote contacts.
     */
open func sync(remotePubkeys: [String])throws  -> SyncResultFfi  {
    return try  FfiConverterTypeSyncResultFFI_lift(try rustCallWithError(FfiConverterTypeStorageCacheError_lift) {
    uniffi_paykit_mobile_fn_method_contactcacheffi_sync(self.uniffiClonePointer(),
        FfiConverterSequenceString.lower(remotePubkeys),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeContactCacheFFI: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ContactCacheFfi

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ContactCacheFfi {
        return ContactCacheFfi(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ContactCacheFfi) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ContactCacheFfi {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ContactCacheFfi, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeContactCacheFFI_lift(_ pointer: UnsafeMutableRawPointer) throws -> ContactCacheFfi {
    return try FfiConverterTypeContactCacheFFI.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeContactCacheFFI_lower(_ value: ContactCacheFfi) -> UnsafeMutableRawPointer {
    return FfiConverterTypeContactCacheFFI.lower(value)
}






/**
 * Async directory operations manager.
 *
 * Provides non-blocking directory operations with callback support.
 */
public protocol DirectoryOperationsAsyncProtocol: AnyObject, Sendable {
    
    /**
     * Add a contact asynchronously.
     */
    func addContact(transport: AuthenticatedTransportFfi, contactPubkey: String) throws 
    
    /**
     * Fetch known contacts asynchronously.
     */
    func fetchKnownContacts(transport: UnauthenticatedTransportFfi, ownerPubkey: String) throws  -> [String]
    
    /**
     * Fetch a specific payment endpoint asynchronously.
     */
    func fetchPaymentEndpoint(transport: UnauthenticatedTransportFfi, ownerPubkey: String, methodId: String) throws  -> String?
    
    /**
     * Fetch all supported payment methods asynchronously.
     */
    func fetchSupportedPayments(transport: UnauthenticatedTransportFfi, ownerPubkey: String) throws  -> [PaymentMethod]
    
    /**
     * List all contacts asynchronously.
     */
    func listContacts(transport: AuthenticatedTransportFfi) throws  -> [String]
    
    /**
     * Publish a payment endpoint asynchronously.
     *
     * This is a blocking call that wraps the async operation.
     * For true non-blocking behavior, use the callback-based methods from mobile SDKs.
     */
    func publishPaymentEndpoint(transport: AuthenticatedTransportFfi, methodId: String, endpointData: String) throws 
    
    /**
     * Remove a contact asynchronously.
     */
    func removeContact(transport: AuthenticatedTransportFfi, contactPubkey: String) throws 
    
    /**
     * Remove a payment endpoint asynchronously.
     */
    func removePaymentEndpoint(transport: AuthenticatedTransportFfi, methodId: String) throws 
    
}
/**
 * Async directory operations manager.
 *
 * Provides non-blocking directory operations with callback support.
 */
open class DirectoryOperationsAsync: DirectoryOperationsAsyncProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_paykit_mobile_fn_clone_directoryoperationsasync(self.pointer, $0) }
    }
    /**
     * Create a new async directory operations manager.
     */
public convenience init()throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_constructor_directoryoperationsasync_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_paykit_mobile_fn_free_directoryoperationsasync(pointer, $0) }
    }

    

    
    /**
     * Add a contact asynchronously.
     */
open func addContact(transport: AuthenticatedTransportFfi, contactPubkey: String)throws   {try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_directoryoperationsasync_add_contact(self.uniffiClonePointer(),
        FfiConverterTypeAuthenticatedTransportFFI_lower(transport),
        FfiConverterString.lower(contactPubkey),$0
    )
}
}
    
    /**
     * Fetch known contacts asynchronously.
     */
open func fetchKnownContacts(transport: UnauthenticatedTransportFfi, ownerPubkey: String)throws  -> [String]  {
    return try  FfiConverterSequenceString.lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_directoryoperationsasync_fetch_known_contacts(self.uniffiClonePointer(),
        FfiConverterTypeUnauthenticatedTransportFFI_lower(transport),
        FfiConverterString.lower(ownerPubkey),$0
    )
})
}
    
    /**
     * Fetch a specific payment endpoint asynchronously.
     */
open func fetchPaymentEndpoint(transport: UnauthenticatedTransportFfi, ownerPubkey: String, methodId: String)throws  -> String?  {
    return try  FfiConverterOptionString.lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_directoryoperationsasync_fetch_payment_endpoint(self.uniffiClonePointer(),
        FfiConverterTypeUnauthenticatedTransportFFI_lower(transport),
        FfiConverterString.lower(ownerPubkey),
        FfiConverterString.lower(methodId),$0
    )
})
}
    
    /**
     * Fetch all supported payment methods asynchronously.
     */
open func fetchSupportedPayments(transport: UnauthenticatedTransportFfi, ownerPubkey: String)throws  -> [PaymentMethod]  {
    return try  FfiConverterSequenceTypePaymentMethod.lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_directoryoperationsasync_fetch_supported_payments(self.uniffiClonePointer(),
        FfiConverterTypeUnauthenticatedTransportFFI_lower(transport),
        FfiConverterString.lower(ownerPubkey),$0
    )
})
}
    
    /**
     * List all contacts asynchronously.
     */
open func listContacts(transport: AuthenticatedTransportFfi)throws  -> [String]  {
    return try  FfiConverterSequenceString.lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_directoryoperationsasync_list_contacts(self.uniffiClonePointer(),
        FfiConverterTypeAuthenticatedTransportFFI_lower(transport),$0
    )
})
}
    
    /**
     * Publish a payment endpoint asynchronously.
     *
     * This is a blocking call that wraps the async operation.
     * For true non-blocking behavior, use the callback-based methods from mobile SDKs.
     */
open func publishPaymentEndpoint(transport: AuthenticatedTransportFfi, methodId: String, endpointData: String)throws   {try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_directoryoperationsasync_publish_payment_endpoint(self.uniffiClonePointer(),
        FfiConverterTypeAuthenticatedTransportFFI_lower(transport),
        FfiConverterString.lower(methodId),
        FfiConverterString.lower(endpointData),$0
    )
}
}
    
    /**
     * Remove a contact asynchronously.
     */
open func removeContact(transport: AuthenticatedTransportFfi, contactPubkey: String)throws   {try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_directoryoperationsasync_remove_contact(self.uniffiClonePointer(),
        FfiConverterTypeAuthenticatedTransportFFI_lower(transport),
        FfiConverterString.lower(contactPubkey),$0
    )
}
}
    
    /**
     * Remove a payment endpoint asynchronously.
     */
open func removePaymentEndpoint(transport: AuthenticatedTransportFfi, methodId: String)throws   {try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_directoryoperationsasync_remove_payment_endpoint(self.uniffiClonePointer(),
        FfiConverterTypeAuthenticatedTransportFFI_lower(transport),
        FfiConverterString.lower(methodId),$0
    )
}
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDirectoryOperationsAsync: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = DirectoryOperationsAsync

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> DirectoryOperationsAsync {
        return DirectoryOperationsAsync(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: DirectoryOperationsAsync) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DirectoryOperationsAsync {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: DirectoryOperationsAsync, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDirectoryOperationsAsync_lift(_ pointer: UnsafeMutableRawPointer) throws -> DirectoryOperationsAsync {
    return try FfiConverterTypeDirectoryOperationsAsync.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDirectoryOperationsAsync_lower(_ value: DirectoryOperationsAsync) -> UnsafeMutableRawPointer {
    return FfiConverterTypeDirectoryOperationsAsync.lower(value)
}






/**
 * Async bridge for executor operations.
 *
 * Provides async wrappers for Bitcoin and Lightning executor operations
 * with timeout handling and cancellation support. This is useful when
 * you need to wrap synchronous wallet operations with timeout handling.
 *
 * # Usage
 *
 * ```ignore
 * let bridge = ExecutorAsyncBridge::new()?;
 *
 * // Execute with default 30s timeout
 * let result = bridge.execute_bitcoin_operation(|| {
 * // Your wallet operation here
 * wallet.send_to_address(address, amount)
 * }, None)?;
 *
 * // Execute with custom 60s timeout
 * let result = bridge.execute_lightning_operation(|| {
 * // Your node operation here
 * node.pay_invoice(invoice)
 * }, Some(60000))?;
 * ```
 *
 * # Timeout Handling
 *
 * If an operation exceeds the timeout, a `PaykitMobileError::Transport`
 * error is returned with message "Bitcoin/Lightning operation timed out".
 *
 * # Thread Safety
 *
 * The bridge manages its own Tokio runtime and is safe to use from any thread.
 * Operations are executed on the runtime's thread pool.
 *
 * # Cancellation
 *
 * Use `execute_with_cancellation()` to get an `AsyncHandle` that can be used
 * to cancel long-running operations.
 */
public protocol ExecutorAsyncBridgeProtocol: AnyObject, Sendable {
    
    /**
     * Get the default timeout in milliseconds.
     */
    func defaultTimeoutMs()  -> UInt64
    
}
/**
 * Async bridge for executor operations.
 *
 * Provides async wrappers for Bitcoin and Lightning executor operations
 * with timeout handling and cancellation support. This is useful when
 * you need to wrap synchronous wallet operations with timeout handling.
 *
 * # Usage
 *
 * ```ignore
 * let bridge = ExecutorAsyncBridge::new()?;
 *
 * // Execute with default 30s timeout
 * let result = bridge.execute_bitcoin_operation(|| {
 * // Your wallet operation here
 * wallet.send_to_address(address, amount)
 * }, None)?;
 *
 * // Execute with custom 60s timeout
 * let result = bridge.execute_lightning_operation(|| {
 * // Your node operation here
 * node.pay_invoice(invoice)
 * }, Some(60000))?;
 * ```
 *
 * # Timeout Handling
 *
 * If an operation exceeds the timeout, a `PaykitMobileError::Transport`
 * error is returned with message "Bitcoin/Lightning operation timed out".
 *
 * # Thread Safety
 *
 * The bridge manages its own Tokio runtime and is safe to use from any thread.
 * Operations are executed on the runtime's thread pool.
 *
 * # Cancellation
 *
 * Use `execute_with_cancellation()` to get an `AsyncHandle` that can be used
 * to cancel long-running operations.
 */
open class ExecutorAsyncBridge: ExecutorAsyncBridgeProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_paykit_mobile_fn_clone_executorasyncbridge(self.pointer, $0) }
    }
    /**
     * Create a new executor async bridge.
     */
public convenience init()throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_constructor_executorasyncbridge_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_paykit_mobile_fn_free_executorasyncbridge(pointer, $0) }
    }

    
    /**
     * Create with custom timeout.
     */
public static func withTimeout(timeoutMs: UInt64)throws  -> ExecutorAsyncBridge  {
    return try  FfiConverterTypeExecutorAsyncBridge_lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_constructor_executorasyncbridge_with_timeout(
        FfiConverterUInt64.lower(timeoutMs),$0
    )
})
}
    

    
    /**
     * Get the default timeout in milliseconds.
     */
open func defaultTimeoutMs() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_paykit_mobile_fn_method_executorasyncbridge_default_timeout_ms(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExecutorAsyncBridge: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ExecutorAsyncBridge

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ExecutorAsyncBridge {
        return ExecutorAsyncBridge(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ExecutorAsyncBridge) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExecutorAsyncBridge {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ExecutorAsyncBridge, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExecutorAsyncBridge_lift(_ pointer: UnsafeMutableRawPointer) throws -> ExecutorAsyncBridge {
    return try FfiConverterTypeExecutorAsyncBridge.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExecutorAsyncBridge_lower(_ value: ExecutorAsyncBridge) -> UnsafeMutableRawPointer {
    return FfiConverterTypeExecutorAsyncBridge.lower(value)
}






/**
 * Main Paykit client for mobile applications.
 */
public protocol PaykitClientProtocol: AnyObject, Sendable {
    
    /**
     * Add a contact to the follows list.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for the owner
     * * `contact_pubkey` - The contact's public key to add
     */
    func addContact(transport: AuthenticatedTransportFfi, contactPubkey: String) throws 
    
    /**
     * Get the configured Bitcoin network.
     */
    func bitcoinNetwork()  -> BitcoinNetworkFfi
    
    /**
     * Calculate proration for a subscription modification.
     */
    func calculateProration(currentAmountSats: Int64, newAmountSats: Int64, periodStart: Int64, periodEnd: Int64, changeDate: Int64) throws  -> ProrationResult
    
    /**
     * Check health of all payment methods.
     */
    func checkHealth()  -> [HealthCheckResult]
    
    /**
     * Create an error message for Noise channel.
     *
     * # Arguments
     *
     * * `code` - Error code
     * * `message` - Error description
     */
    func createNoiseErrorMessage(code: String, message: String) throws  -> NoisePaymentMessage
    
    /**
     * Create a payment request.
     */
    func createPaymentRequest(fromPubkey: String, toPubkey: String, amountSats: Int64, currency: String, methodId: String, description: String, expiresInSecs: UInt64?) throws  -> PaymentRequest
    
    /**
     * Create a new receipt.
     */
    func createReceipt(payer: String, payee: String, methodId: String, amount: String?, currency: String?) throws  -> Receipt
    
    /**
     * Create a receipt confirmation message for Noise channel.
     *
     * # Arguments
     *
     * * `receipt_id` - The receipt ID being confirmed
     * * `payer_pubkey` - Payer's public key
     * * `payee_pubkey` - Payee's public key
     * * `method_id` - Payment method used
     * * `amount` - Payment amount
     * * `currency` - Currency code
     * * `signature` - Optional signature from payee
     */
    func createReceiptConfirmationMessage(receiptId: String, payerPubkey: String, payeePubkey: String, methodId: String, amount: String?, currency: String?, signature: String?) throws  -> NoisePaymentMessage
    
    /**
     * Create a receipt request message for Noise channel.
     *
     * # Arguments
     *
     * * `receipt_id` - Unique identifier for this receipt
     * * `payer_pubkey` - Payer's public key (z-base32)
     * * `payee_pubkey` - Payee's public key (z-base32)
     * * `method_id` - Payment method identifier
     * * `amount` - Optional payment amount
     * * `currency` - Optional currency code
     */
    func createReceiptRequestMessage(receiptId: String, payerPubkey: String, payeePubkey: String, methodId: String, amount: String?, currency: String?) throws  -> NoisePaymentMessage
    
    /**
     * Create a new subscription.
     */
    func createSubscription(subscriber: String, provider: String, terms: SubscriptionTerms) throws  -> Subscription
    
    /**
     * Get days remaining in current billing period.
     */
    func daysRemainingInPeriod(periodEnd: Int64)  -> UInt32
    
    /**
     * Discover a Noise endpoint for a recipient.
     *
     * Queries the recipient's public directory for their Noise server information.
     *
     * # Arguments
     *
     * * `transport` - Unauthenticated transport for reading
     * * `recipient_pubkey` - The recipient's public key (z-base32 encoded)
     *
     * # Returns
     *
     * The noise endpoint info if found, None otherwise.
     *
     * # Example
     *
     * ```ignore
     * let transport = UnauthenticatedTransportFFI::new_mock();
     * if let Some(endpoint) = client.discover_noise_endpoint(transport, "8pinxxgqs41...")? {
     * println!("Connecting to {}:{}", endpoint.host, endpoint.port);
     * }
     * ```
     */
    func discoverNoiseEndpoint(transport: UnauthenticatedTransportFfi, recipientPubkey: String) throws  -> NoiseEndpointInfo?
    
    /**
     * Execute a payment using the registered executor.
     *
     * This method executes a real payment using the wallet executor that was
     * registered via `register_bitcoin_executor` or `register_lightning_executor`.
     *
     * # Arguments
     *
     * * `method_id` - Payment method ("onchain" or "lightning")
     * * `endpoint` - Payment destination (Bitcoin address or Lightning invoice)
     * * `amount_sats` - Amount to send in satoshis
     * * `metadata_json` - Optional JSON metadata (e.g., fee rate preferences)
     *
     * # Returns
     *
     * `PaymentExecutionResult` with success/failure status and execution details.
     *
     * # Example
     *
     * ```ignore
     * // After registering executors
     * let result = client.execute_payment(
     * "lightning",
     * "lnbc1000n1...",
     * 1000,
     * None
     * )?;
     *
     * if result.success {
     * println!("Payment succeeded: {}", result.execution_id);
     * }
     * ```
     */
    func executePayment(methodId: String, endpoint: String, amountSats: UInt64, metadataJson: String?) throws  -> PaymentExecutionResult
    
    /**
     * Extract public key from scanned QR code.
     */
    func extractKeyFromQr(scannedData: String)  -> String?
    
    /**
     * Extract payment method from scanned QR code.
     */
    func extractMethodFromQr(scannedData: String)  -> String?
    
    /**
     * Fetch known contacts for a public key.
     *
     * # Arguments
     *
     * * `transport` - Unauthenticated transport for reading
     * * `owner_pubkey` - The public key to query
     *
     * # Returns
     *
     * List of contact public keys.
     */
    func fetchKnownContacts(transport: UnauthenticatedTransportFfi, ownerPubkey: String) throws  -> [String]
    
    /**
     * Fetch a specific payment endpoint for a public key.
     *
     * # Arguments
     *
     * * `transport` - Unauthenticated transport for reading
     * * `owner_pubkey` - The public key to query
     * * `method_id` - The payment method to fetch
     *
     * # Returns
     *
     * The endpoint data if found, None otherwise.
     */
    func fetchPaymentEndpoint(transport: UnauthenticatedTransportFfi, ownerPubkey: String, methodId: String) throws  -> String?
    
    /**
     * Fetch all supported payment methods for a public key.
     *
     * # Arguments
     *
     * * `transport` - Unauthenticated transport for reading
     * * `owner_pubkey` - The public key to query (z-base32 encoded)
     *
     * # Returns
     *
     * List of payment methods with their endpoints.
     *
     * # Example
     *
     * ```ignore
     * let transport = UnauthenticatedTransportFFI::new_mock();
     * let methods = client.fetch_supported_payments(transport, "8pinxxgqs41...")?;
     * for method in methods {
     * println!("{}: {}", method.method_id, method.endpoint);
     * }
     * ```
     */
    func fetchSupportedPayments(transport: UnauthenticatedTransportFfi, ownerPubkey: String) throws  -> [PaymentMethod]
    
    /**
     * Generate a payment proof from an execution result.
     *
     * After a successful payment, call this to generate cryptographic proof
     * of payment (e.g., transaction ID for on-chain, preimage for Lightning).
     *
     * # Arguments
     *
     * * `method_id` - Payment method used
     * * `execution_data_json` - The execution data from `execute_payment` result
     *
     * # Returns
     *
     * `PaymentProofResult` containing the proof type and data.
     */
    func generatePaymentProof(methodId: String, executionDataJson: String) throws  -> PaymentProofResult
    
    /**
     * Get health status of a specific method.
     */
    func getHealthStatus(methodId: String)  -> HealthStatus?
    
    /**
     * Get all in-progress payments.
     */
    func getInProgressPayments()  -> [PaymentStatusInfo]
    
    /**
     * Get payment status for a receipt.
     */
    func getPaymentStatus(receiptId: String)  -> PaymentStatusInfo?
    
    /**
     * Check if a Bitcoin executor has been registered.
     *
     * Note: This checks if the onchain method is registered. After calling
     * `register_bitcoin_executor`, this will return true.
     */
    func hasBitcoinExecutor()  -> Bool
    
    /**
     * Check if a Lightning executor has been registered.
     *
     * Note: This checks if the lightning method is registered. After calling
     * `register_lightning_executor`, this will return true.
     */
    func hasLightningExecutor()  -> Bool
    
    /**
     * Check if a method is usable (healthy or degraded).
     */
    func isMethodUsable(methodId: String)  -> Bool
    
    /**
     * Check if scanned data looks like a Paykit URI.
     */
    func isPaykitQr(scannedData: String)  -> Bool
    
    /**
     * Get the configured Lightning network.
     */
    func lightningNetwork()  -> LightningNetworkFfi
    
    /**
     * List all contacts.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for the owner
     *
     * # Returns
     *
     * List of contact public keys.
     */
    func listContacts(transport: AuthenticatedTransportFfi) throws  -> [String]
    
    /**
     * Get the list of registered payment methods.
     */
    func listMethods()  -> [String]
    
    /**
     * Parse a payment message from JSON.
     *
     * # Arguments
     *
     * * `json` - The JSON string to parse
     */
    func parseNoisePaymentMessage(json: String) throws  -> NoisePaymentMessage
    
    /**
     * Parse receipt metadata as JSON.
     */
    func parseReceiptMetadata(metadataJson: String) throws  -> String
    
    /**
     * Parse scanned QR code data as a Paykit URI.
     */
    func parseScannedQr(scannedData: String) throws  -> ScannedUri
    
    /**
     * Publish a Noise endpoint to the directory.
     *
     * Makes this device discoverable for receiving payments via Noise protocol.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for writing
     * * `host` - Host address where the Noise server is listening
     * * `port` - Port number where the Noise server is listening
     * * `noise_pubkey` - This server's Noise public key (X25519, hex encoded)
     * * `metadata` - Optional metadata about the endpoint
     */
    func publishNoiseEndpoint(transport: AuthenticatedTransportFfi, host: String, port: UInt16, noisePubkey: String, metadata: String?) throws 
    
    /**
     * Publish a payment endpoint to the directory.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for the owner
     * * `method_id` - Payment method identifier (e.g., "lightning", "onchain")
     * * `endpoint_data` - The endpoint data to publish
     *
     * # Example
     *
     * ```ignore
     * let transport = AuthenticatedTransportFFI::from_session_json(session, pubkey)?;
     * client.publish_payment_endpoint(transport, "lightning", "lnbc1...")?;
     * ```
     */
    func publishPaymentEndpoint(transport: AuthenticatedTransportFfi, methodId: String, endpointData: String) throws 
    
    /**
     * Register a Bitcoin executor for on-chain payments.
     *
     * This allows Bitkit or other wallets to provide their wallet implementation
     * as the executor for on-chain Bitcoin payments. The executor handles:
     * - Sending payments to addresses
     * - Estimating fees
     * - Verifying transactions
     *
     * # Arguments
     *
     * * `executor` - Implementation of `BitcoinExecutorFFI` from the wallet
     *
     * # Example (Swift)
     *
     * ```swift
     * class BitkitBitcoinExecutor: BitcoinExecutorFFI {
     * func sendToAddress(address: String, amountSats: UInt64, feeRate: Double?) throws -> BitcoinTxResultFFI {
     * // Implement using Bitkit wallet
     * }
     * // ... other methods
     * }
     *
     * let client = PaykitClient.newWithNetwork(
     * bitcoinNetwork: .mainnet,
     * lightningNetwork: .mainnet
     * )
     * try client.registerBitcoinExecutor(executor: BitkitBitcoinExecutor())
     * ```
     */
    func registerBitcoinExecutor(executor: BitcoinExecutorFfi) throws 
    
    /**
     * Register a Lightning executor for Lightning Network payments.
     *
     * This allows Bitkit or other wallets to provide their Lightning node
     * implementation as the executor for Lightning payments. The executor handles:
     * - Paying BOLT11 invoices
     * - Decoding invoices
     * - Estimating routing fees
     * - Verifying payments via preimage
     *
     * # Arguments
     *
     * * `executor` - Implementation of `LightningExecutorFFI` from the wallet
     *
     * # Example (Swift)
     *
     * ```swift
     * class BitkitLightningExecutor: LightningExecutorFFI {
     * func payInvoice(invoice: String, amountMsat: UInt64?, maxFeeMsat: UInt64?) throws -> LightningPaymentResultFFI {
     * // Implement using Bitkit Lightning node
     * }
     * // ... other methods
     * }
     *
     * try client.registerLightningExecutor(executor: BitkitLightningExecutor())
     * ```
     */
    func registerLightningExecutor(executor: LightningExecutorFfi) throws 
    
    /**
     * Remove a contact from the follows list.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for the owner
     * * `contact_pubkey` - The contact's public key to remove
     */
    func removeContact(transport: AuthenticatedTransportFfi, contactPubkey: String) throws 
    
    /**
     * Remove the Noise endpoint from the directory.
     *
     * Makes this device no longer discoverable for Noise payments.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for writing
     */
    func removeNoiseEndpoint(transport: AuthenticatedTransportFfi) throws 
    
    /**
     * Remove a payment endpoint from the directory.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for the owner
     * * `method_id` - Payment method identifier to remove
     */
    func removePaymentEndpointFromDirectory(transport: AuthenticatedTransportFfi, methodId: String) throws 
    
    /**
     * Select the best payment method from supported options.
     */
    func selectMethod(supportedMethods: [PaymentMethod], amountSats: UInt64, preferences: SelectionPreferences?) throws  -> SelectionResult
    
    /**
     * Validate an endpoint for a specific method.
     */
    func validateEndpoint(methodId: String, endpoint: String) throws  -> Bool
    
}
/**
 * Main Paykit client for mobile applications.
 */
open class PaykitClient: PaykitClientProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_paykit_mobile_fn_clone_paykitclient(self.pointer, $0) }
    }
    /**
     * Create a new Paykit client with default (mainnet) network configuration.
     */
public convenience init()throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_constructor_paykitclient_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_paykit_mobile_fn_free_paykitclient(pointer, $0) }
    }

    
    /**
     * Create a new Paykit client with specific network configuration.
     *
     * # Arguments
     *
     * * `bitcoin_network` - Bitcoin network to use (Mainnet, Testnet, or Regtest)
     * * `lightning_network` - Lightning network to use (Mainnet, Testnet, or Regtest)
     *
     * # Example
     *
     * ```ignore
     * // For testnet development
     * let client = PaykitClient::new_with_network(
     * BitcoinNetworkFFI::Testnet,
     * LightningNetworkFFI::Testnet,
     * )?;
     * ```
     */
public static func newWithNetwork(bitcoinNetwork: BitcoinNetworkFfi, lightningNetwork: LightningNetworkFfi)throws  -> PaykitClient  {
    return try  FfiConverterTypePaykitClient_lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_constructor_paykitclient_new_with_network(
        FfiConverterTypeBitcoinNetworkFFI_lower(bitcoinNetwork),
        FfiConverterTypeLightningNetworkFFI_lower(lightningNetwork),$0
    )
})
}
    

    
    /**
     * Add a contact to the follows list.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for the owner
     * * `contact_pubkey` - The contact's public key to add
     */
open func addContact(transport: AuthenticatedTransportFfi, contactPubkey: String)throws   {try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_add_contact(self.uniffiClonePointer(),
        FfiConverterTypeAuthenticatedTransportFFI_lower(transport),
        FfiConverterString.lower(contactPubkey),$0
    )
}
}
    
    /**
     * Get the configured Bitcoin network.
     */
open func bitcoinNetwork() -> BitcoinNetworkFfi  {
    return try!  FfiConverterTypeBitcoinNetworkFFI_lift(try! rustCall() {
    uniffi_paykit_mobile_fn_method_paykitclient_bitcoin_network(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Calculate proration for a subscription modification.
     */
open func calculateProration(currentAmountSats: Int64, newAmountSats: Int64, periodStart: Int64, periodEnd: Int64, changeDate: Int64)throws  -> ProrationResult  {
    return try  FfiConverterTypeProrationResult_lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_calculate_proration(self.uniffiClonePointer(),
        FfiConverterInt64.lower(currentAmountSats),
        FfiConverterInt64.lower(newAmountSats),
        FfiConverterInt64.lower(periodStart),
        FfiConverterInt64.lower(periodEnd),
        FfiConverterInt64.lower(changeDate),$0
    )
})
}
    
    /**
     * Check health of all payment methods.
     */
open func checkHealth() -> [HealthCheckResult]  {
    return try!  FfiConverterSequenceTypeHealthCheckResult.lift(try! rustCall() {
    uniffi_paykit_mobile_fn_method_paykitclient_check_health(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Create an error message for Noise channel.
     *
     * # Arguments
     *
     * * `code` - Error code
     * * `message` - Error description
     */
open func createNoiseErrorMessage(code: String, message: String)throws  -> NoisePaymentMessage  {
    return try  FfiConverterTypeNoisePaymentMessage_lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_create_noise_error_message(self.uniffiClonePointer(),
        FfiConverterString.lower(code),
        FfiConverterString.lower(message),$0
    )
})
}
    
    /**
     * Create a payment request.
     */
open func createPaymentRequest(fromPubkey: String, toPubkey: String, amountSats: Int64, currency: String, methodId: String, description: String, expiresInSecs: UInt64?)throws  -> PaymentRequest  {
    return try  FfiConverterTypePaymentRequest_lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_create_payment_request(self.uniffiClonePointer(),
        FfiConverterString.lower(fromPubkey),
        FfiConverterString.lower(toPubkey),
        FfiConverterInt64.lower(amountSats),
        FfiConverterString.lower(currency),
        FfiConverterString.lower(methodId),
        FfiConverterString.lower(description),
        FfiConverterOptionUInt64.lower(expiresInSecs),$0
    )
})
}
    
    /**
     * Create a new receipt.
     */
open func createReceipt(payer: String, payee: String, methodId: String, amount: String?, currency: String?)throws  -> Receipt  {
    return try  FfiConverterTypeReceipt_lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_create_receipt(self.uniffiClonePointer(),
        FfiConverterString.lower(payer),
        FfiConverterString.lower(payee),
        FfiConverterString.lower(methodId),
        FfiConverterOptionString.lower(amount),
        FfiConverterOptionString.lower(currency),$0
    )
})
}
    
    /**
     * Create a receipt confirmation message for Noise channel.
     *
     * # Arguments
     *
     * * `receipt_id` - The receipt ID being confirmed
     * * `payer_pubkey` - Payer's public key
     * * `payee_pubkey` - Payee's public key
     * * `method_id` - Payment method used
     * * `amount` - Payment amount
     * * `currency` - Currency code
     * * `signature` - Optional signature from payee
     */
open func createReceiptConfirmationMessage(receiptId: String, payerPubkey: String, payeePubkey: String, methodId: String, amount: String?, currency: String?, signature: String?)throws  -> NoisePaymentMessage  {
    return try  FfiConverterTypeNoisePaymentMessage_lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_create_receipt_confirmation_message(self.uniffiClonePointer(),
        FfiConverterString.lower(receiptId),
        FfiConverterString.lower(payerPubkey),
        FfiConverterString.lower(payeePubkey),
        FfiConverterString.lower(methodId),
        FfiConverterOptionString.lower(amount),
        FfiConverterOptionString.lower(currency),
        FfiConverterOptionString.lower(signature),$0
    )
})
}
    
    /**
     * Create a receipt request message for Noise channel.
     *
     * # Arguments
     *
     * * `receipt_id` - Unique identifier for this receipt
     * * `payer_pubkey` - Payer's public key (z-base32)
     * * `payee_pubkey` - Payee's public key (z-base32)
     * * `method_id` - Payment method identifier
     * * `amount` - Optional payment amount
     * * `currency` - Optional currency code
     */
open func createReceiptRequestMessage(receiptId: String, payerPubkey: String, payeePubkey: String, methodId: String, amount: String?, currency: String?)throws  -> NoisePaymentMessage  {
    return try  FfiConverterTypeNoisePaymentMessage_lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_create_receipt_request_message(self.uniffiClonePointer(),
        FfiConverterString.lower(receiptId),
        FfiConverterString.lower(payerPubkey),
        FfiConverterString.lower(payeePubkey),
        FfiConverterString.lower(methodId),
        FfiConverterOptionString.lower(amount),
        FfiConverterOptionString.lower(currency),$0
    )
})
}
    
    /**
     * Create a new subscription.
     */
open func createSubscription(subscriber: String, provider: String, terms: SubscriptionTerms)throws  -> Subscription  {
    return try  FfiConverterTypeSubscription_lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_create_subscription(self.uniffiClonePointer(),
        FfiConverterString.lower(subscriber),
        FfiConverterString.lower(provider),
        FfiConverterTypeSubscriptionTerms_lower(terms),$0
    )
})
}
    
    /**
     * Get days remaining in current billing period.
     */
open func daysRemainingInPeriod(periodEnd: Int64) -> UInt32  {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_paykit_mobile_fn_method_paykitclient_days_remaining_in_period(self.uniffiClonePointer(),
        FfiConverterInt64.lower(periodEnd),$0
    )
})
}
    
    /**
     * Discover a Noise endpoint for a recipient.
     *
     * Queries the recipient's public directory for their Noise server information.
     *
     * # Arguments
     *
     * * `transport` - Unauthenticated transport for reading
     * * `recipient_pubkey` - The recipient's public key (z-base32 encoded)
     *
     * # Returns
     *
     * The noise endpoint info if found, None otherwise.
     *
     * # Example
     *
     * ```ignore
     * let transport = UnauthenticatedTransportFFI::new_mock();
     * if let Some(endpoint) = client.discover_noise_endpoint(transport, "8pinxxgqs41...")? {
     * println!("Connecting to {}:{}", endpoint.host, endpoint.port);
     * }
     * ```
     */
open func discoverNoiseEndpoint(transport: UnauthenticatedTransportFfi, recipientPubkey: String)throws  -> NoiseEndpointInfo?  {
    return try  FfiConverterOptionTypeNoiseEndpointInfo.lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_discover_noise_endpoint(self.uniffiClonePointer(),
        FfiConverterTypeUnauthenticatedTransportFFI_lower(transport),
        FfiConverterString.lower(recipientPubkey),$0
    )
})
}
    
    /**
     * Execute a payment using the registered executor.
     *
     * This method executes a real payment using the wallet executor that was
     * registered via `register_bitcoin_executor` or `register_lightning_executor`.
     *
     * # Arguments
     *
     * * `method_id` - Payment method ("onchain" or "lightning")
     * * `endpoint` - Payment destination (Bitcoin address or Lightning invoice)
     * * `amount_sats` - Amount to send in satoshis
     * * `metadata_json` - Optional JSON metadata (e.g., fee rate preferences)
     *
     * # Returns
     *
     * `PaymentExecutionResult` with success/failure status and execution details.
     *
     * # Example
     *
     * ```ignore
     * // After registering executors
     * let result = client.execute_payment(
     * "lightning",
     * "lnbc1000n1...",
     * 1000,
     * None
     * )?;
     *
     * if result.success {
     * println!("Payment succeeded: {}", result.execution_id);
     * }
     * ```
     */
open func executePayment(methodId: String, endpoint: String, amountSats: UInt64, metadataJson: String?)throws  -> PaymentExecutionResult  {
    return try  FfiConverterTypePaymentExecutionResult_lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_execute_payment(self.uniffiClonePointer(),
        FfiConverterString.lower(methodId),
        FfiConverterString.lower(endpoint),
        FfiConverterUInt64.lower(amountSats),
        FfiConverterOptionString.lower(metadataJson),$0
    )
})
}
    
    /**
     * Extract public key from scanned QR code.
     */
open func extractKeyFromQr(scannedData: String) -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_paykit_mobile_fn_method_paykitclient_extract_key_from_qr(self.uniffiClonePointer(),
        FfiConverterString.lower(scannedData),$0
    )
})
}
    
    /**
     * Extract payment method from scanned QR code.
     */
open func extractMethodFromQr(scannedData: String) -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_paykit_mobile_fn_method_paykitclient_extract_method_from_qr(self.uniffiClonePointer(),
        FfiConverterString.lower(scannedData),$0
    )
})
}
    
    /**
     * Fetch known contacts for a public key.
     *
     * # Arguments
     *
     * * `transport` - Unauthenticated transport for reading
     * * `owner_pubkey` - The public key to query
     *
     * # Returns
     *
     * List of contact public keys.
     */
open func fetchKnownContacts(transport: UnauthenticatedTransportFfi, ownerPubkey: String)throws  -> [String]  {
    return try  FfiConverterSequenceString.lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_fetch_known_contacts(self.uniffiClonePointer(),
        FfiConverterTypeUnauthenticatedTransportFFI_lower(transport),
        FfiConverterString.lower(ownerPubkey),$0
    )
})
}
    
    /**
     * Fetch a specific payment endpoint for a public key.
     *
     * # Arguments
     *
     * * `transport` - Unauthenticated transport for reading
     * * `owner_pubkey` - The public key to query
     * * `method_id` - The payment method to fetch
     *
     * # Returns
     *
     * The endpoint data if found, None otherwise.
     */
open func fetchPaymentEndpoint(transport: UnauthenticatedTransportFfi, ownerPubkey: String, methodId: String)throws  -> String?  {
    return try  FfiConverterOptionString.lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_fetch_payment_endpoint(self.uniffiClonePointer(),
        FfiConverterTypeUnauthenticatedTransportFFI_lower(transport),
        FfiConverterString.lower(ownerPubkey),
        FfiConverterString.lower(methodId),$0
    )
})
}
    
    /**
     * Fetch all supported payment methods for a public key.
     *
     * # Arguments
     *
     * * `transport` - Unauthenticated transport for reading
     * * `owner_pubkey` - The public key to query (z-base32 encoded)
     *
     * # Returns
     *
     * List of payment methods with their endpoints.
     *
     * # Example
     *
     * ```ignore
     * let transport = UnauthenticatedTransportFFI::new_mock();
     * let methods = client.fetch_supported_payments(transport, "8pinxxgqs41...")?;
     * for method in methods {
     * println!("{}: {}", method.method_id, method.endpoint);
     * }
     * ```
     */
open func fetchSupportedPayments(transport: UnauthenticatedTransportFfi, ownerPubkey: String)throws  -> [PaymentMethod]  {
    return try  FfiConverterSequenceTypePaymentMethod.lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_fetch_supported_payments(self.uniffiClonePointer(),
        FfiConverterTypeUnauthenticatedTransportFFI_lower(transport),
        FfiConverterString.lower(ownerPubkey),$0
    )
})
}
    
    /**
     * Generate a payment proof from an execution result.
     *
     * After a successful payment, call this to generate cryptographic proof
     * of payment (e.g., transaction ID for on-chain, preimage for Lightning).
     *
     * # Arguments
     *
     * * `method_id` - Payment method used
     * * `execution_data_json` - The execution data from `execute_payment` result
     *
     * # Returns
     *
     * `PaymentProofResult` containing the proof type and data.
     */
open func generatePaymentProof(methodId: String, executionDataJson: String)throws  -> PaymentProofResult  {
    return try  FfiConverterTypePaymentProofResult_lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_generate_payment_proof(self.uniffiClonePointer(),
        FfiConverterString.lower(methodId),
        FfiConverterString.lower(executionDataJson),$0
    )
})
}
    
    /**
     * Get health status of a specific method.
     */
open func getHealthStatus(methodId: String) -> HealthStatus?  {
    return try!  FfiConverterOptionTypeHealthStatus.lift(try! rustCall() {
    uniffi_paykit_mobile_fn_method_paykitclient_get_health_status(self.uniffiClonePointer(),
        FfiConverterString.lower(methodId),$0
    )
})
}
    
    /**
     * Get all in-progress payments.
     */
open func getInProgressPayments() -> [PaymentStatusInfo]  {
    return try!  FfiConverterSequenceTypePaymentStatusInfo.lift(try! rustCall() {
    uniffi_paykit_mobile_fn_method_paykitclient_get_in_progress_payments(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get payment status for a receipt.
     */
open func getPaymentStatus(receiptId: String) -> PaymentStatusInfo?  {
    return try!  FfiConverterOptionTypePaymentStatusInfo.lift(try! rustCall() {
    uniffi_paykit_mobile_fn_method_paykitclient_get_payment_status(self.uniffiClonePointer(),
        FfiConverterString.lower(receiptId),$0
    )
})
}
    
    /**
     * Check if a Bitcoin executor has been registered.
     *
     * Note: This checks if the onchain method is registered. After calling
     * `register_bitcoin_executor`, this will return true.
     */
open func hasBitcoinExecutor() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_paykit_mobile_fn_method_paykitclient_has_bitcoin_executor(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Check if a Lightning executor has been registered.
     *
     * Note: This checks if the lightning method is registered. After calling
     * `register_lightning_executor`, this will return true.
     */
open func hasLightningExecutor() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_paykit_mobile_fn_method_paykitclient_has_lightning_executor(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Check if a method is usable (healthy or degraded).
     */
open func isMethodUsable(methodId: String) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_paykit_mobile_fn_method_paykitclient_is_method_usable(self.uniffiClonePointer(),
        FfiConverterString.lower(methodId),$0
    )
})
}
    
    /**
     * Check if scanned data looks like a Paykit URI.
     */
open func isPaykitQr(scannedData: String) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_paykit_mobile_fn_method_paykitclient_is_paykit_qr(self.uniffiClonePointer(),
        FfiConverterString.lower(scannedData),$0
    )
})
}
    
    /**
     * Get the configured Lightning network.
     */
open func lightningNetwork() -> LightningNetworkFfi  {
    return try!  FfiConverterTypeLightningNetworkFFI_lift(try! rustCall() {
    uniffi_paykit_mobile_fn_method_paykitclient_lightning_network(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * List all contacts.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for the owner
     *
     * # Returns
     *
     * List of contact public keys.
     */
open func listContacts(transport: AuthenticatedTransportFfi)throws  -> [String]  {
    return try  FfiConverterSequenceString.lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_list_contacts(self.uniffiClonePointer(),
        FfiConverterTypeAuthenticatedTransportFFI_lower(transport),$0
    )
})
}
    
    /**
     * Get the list of registered payment methods.
     */
open func listMethods() -> [String]  {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_paykit_mobile_fn_method_paykitclient_list_methods(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Parse a payment message from JSON.
     *
     * # Arguments
     *
     * * `json` - The JSON string to parse
     */
open func parseNoisePaymentMessage(json: String)throws  -> NoisePaymentMessage  {
    return try  FfiConverterTypeNoisePaymentMessage_lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_parse_noise_payment_message(self.uniffiClonePointer(),
        FfiConverterString.lower(json),$0
    )
})
}
    
    /**
     * Parse receipt metadata as JSON.
     */
open func parseReceiptMetadata(metadataJson: String)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_parse_receipt_metadata(self.uniffiClonePointer(),
        FfiConverterString.lower(metadataJson),$0
    )
})
}
    
    /**
     * Parse scanned QR code data as a Paykit URI.
     */
open func parseScannedQr(scannedData: String)throws  -> ScannedUri  {
    return try  FfiConverterTypeScannedUri_lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_parse_scanned_qr(self.uniffiClonePointer(),
        FfiConverterString.lower(scannedData),$0
    )
})
}
    
    /**
     * Publish a Noise endpoint to the directory.
     *
     * Makes this device discoverable for receiving payments via Noise protocol.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for writing
     * * `host` - Host address where the Noise server is listening
     * * `port` - Port number where the Noise server is listening
     * * `noise_pubkey` - This server's Noise public key (X25519, hex encoded)
     * * `metadata` - Optional metadata about the endpoint
     */
open func publishNoiseEndpoint(transport: AuthenticatedTransportFfi, host: String, port: UInt16, noisePubkey: String, metadata: String?)throws   {try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_publish_noise_endpoint(self.uniffiClonePointer(),
        FfiConverterTypeAuthenticatedTransportFFI_lower(transport),
        FfiConverterString.lower(host),
        FfiConverterUInt16.lower(port),
        FfiConverterString.lower(noisePubkey),
        FfiConverterOptionString.lower(metadata),$0
    )
}
}
    
    /**
     * Publish a payment endpoint to the directory.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for the owner
     * * `method_id` - Payment method identifier (e.g., "lightning", "onchain")
     * * `endpoint_data` - The endpoint data to publish
     *
     * # Example
     *
     * ```ignore
     * let transport = AuthenticatedTransportFFI::from_session_json(session, pubkey)?;
     * client.publish_payment_endpoint(transport, "lightning", "lnbc1...")?;
     * ```
     */
open func publishPaymentEndpoint(transport: AuthenticatedTransportFfi, methodId: String, endpointData: String)throws   {try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_publish_payment_endpoint(self.uniffiClonePointer(),
        FfiConverterTypeAuthenticatedTransportFFI_lower(transport),
        FfiConverterString.lower(methodId),
        FfiConverterString.lower(endpointData),$0
    )
}
}
    
    /**
     * Register a Bitcoin executor for on-chain payments.
     *
     * This allows Bitkit or other wallets to provide their wallet implementation
     * as the executor for on-chain Bitcoin payments. The executor handles:
     * - Sending payments to addresses
     * - Estimating fees
     * - Verifying transactions
     *
     * # Arguments
     *
     * * `executor` - Implementation of `BitcoinExecutorFFI` from the wallet
     *
     * # Example (Swift)
     *
     * ```swift
     * class BitkitBitcoinExecutor: BitcoinExecutorFFI {
     * func sendToAddress(address: String, amountSats: UInt64, feeRate: Double?) throws -> BitcoinTxResultFFI {
     * // Implement using Bitkit wallet
     * }
     * // ... other methods
     * }
     *
     * let client = PaykitClient.newWithNetwork(
     * bitcoinNetwork: .mainnet,
     * lightningNetwork: .mainnet
     * )
     * try client.registerBitcoinExecutor(executor: BitkitBitcoinExecutor())
     * ```
     */
open func registerBitcoinExecutor(executor: BitcoinExecutorFfi)throws   {try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_register_bitcoin_executor(self.uniffiClonePointer(),
        FfiConverterCallbackInterfaceBitcoinExecutorFfi_lower(executor),$0
    )
}
}
    
    /**
     * Register a Lightning executor for Lightning Network payments.
     *
     * This allows Bitkit or other wallets to provide their Lightning node
     * implementation as the executor for Lightning payments. The executor handles:
     * - Paying BOLT11 invoices
     * - Decoding invoices
     * - Estimating routing fees
     * - Verifying payments via preimage
     *
     * # Arguments
     *
     * * `executor` - Implementation of `LightningExecutorFFI` from the wallet
     *
     * # Example (Swift)
     *
     * ```swift
     * class BitkitLightningExecutor: LightningExecutorFFI {
     * func payInvoice(invoice: String, amountMsat: UInt64?, maxFeeMsat: UInt64?) throws -> LightningPaymentResultFFI {
     * // Implement using Bitkit Lightning node
     * }
     * // ... other methods
     * }
     *
     * try client.registerLightningExecutor(executor: BitkitLightningExecutor())
     * ```
     */
open func registerLightningExecutor(executor: LightningExecutorFfi)throws   {try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_register_lightning_executor(self.uniffiClonePointer(),
        FfiConverterCallbackInterfaceLightningExecutorFfi_lower(executor),$0
    )
}
}
    
    /**
     * Remove a contact from the follows list.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for the owner
     * * `contact_pubkey` - The contact's public key to remove
     */
open func removeContact(transport: AuthenticatedTransportFfi, contactPubkey: String)throws   {try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_remove_contact(self.uniffiClonePointer(),
        FfiConverterTypeAuthenticatedTransportFFI_lower(transport),
        FfiConverterString.lower(contactPubkey),$0
    )
}
}
    
    /**
     * Remove the Noise endpoint from the directory.
     *
     * Makes this device no longer discoverable for Noise payments.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for writing
     */
open func removeNoiseEndpoint(transport: AuthenticatedTransportFfi)throws   {try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_remove_noise_endpoint(self.uniffiClonePointer(),
        FfiConverterTypeAuthenticatedTransportFFI_lower(transport),$0
    )
}
}
    
    /**
     * Remove a payment endpoint from the directory.
     *
     * # Arguments
     *
     * * `transport` - Authenticated transport for the owner
     * * `method_id` - Payment method identifier to remove
     */
open func removePaymentEndpointFromDirectory(transport: AuthenticatedTransportFfi, methodId: String)throws   {try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_remove_payment_endpoint_from_directory(self.uniffiClonePointer(),
        FfiConverterTypeAuthenticatedTransportFFI_lower(transport),
        FfiConverterString.lower(methodId),$0
    )
}
}
    
    /**
     * Select the best payment method from supported options.
     */
open func selectMethod(supportedMethods: [PaymentMethod], amountSats: UInt64, preferences: SelectionPreferences?)throws  -> SelectionResult  {
    return try  FfiConverterTypeSelectionResult_lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_select_method(self.uniffiClonePointer(),
        FfiConverterSequenceTypePaymentMethod.lower(supportedMethods),
        FfiConverterUInt64.lower(amountSats),
        FfiConverterOptionTypeSelectionPreferences.lower(preferences),$0
    )
})
}
    
    /**
     * Validate an endpoint for a specific method.
     */
open func validateEndpoint(methodId: String, endpoint: String)throws  -> Bool  {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitclient_validate_endpoint(self.uniffiClonePointer(),
        FfiConverterString.lower(methodId),
        FfiConverterString.lower(endpoint),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaykitClient: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PaykitClient

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PaykitClient {
        return PaykitClient(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PaykitClient) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaykitClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PaykitClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaykitClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> PaykitClient {
    return try FfiConverterTypePaykitClient.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaykitClient_lower(_ value: PaykitClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypePaykitClient.lower(value)
}






/**
 * FFI wrapper for PaykitInteractiveManager.
 *
 * This provides a high-level interface for managing interactive payment flows
 * over Noise channels. Mobile apps use this to:
 *
 * 1. Process incoming messages and generate responses
 * 2. Initiate payment flows
 * 3. Manage receipts and private endpoints
 *
 * # Thread Safety
 *
 * This type is thread-safe and can be used from multiple threads.
 */
public protocol PaykitInteractiveManagerFfiProtocol: AnyObject, Sendable {
    
    /**
     * Create a private endpoint offer message.
     *
     * Use this to offer a private payment endpoint to a peer.
     *
     * # Arguments
     *
     * * `method_id` - Payment method (e.g., "lightning")
     * * `endpoint` - The endpoint to offer (e.g., Lightning invoice)
     *
     * # Returns
     *
     * JSON message to send over Noise channel.
     */
    func createEndpointOffer(methodId: String, endpoint: String) throws  -> String
    
    /**
     * Create a payment request message to initiate a payment flow.
     *
     * Use this to create the initial message for requesting payment from a peer.
     *
     * # Arguments
     *
     * * `payer` - Your public key (the one paying)
     * * `payee` - The recipient's public key
     * * `method_id` - Payment method (e.g., "lightning", "onchain")
     * * `amount` - Optional amount (as string, e.g., "1000")
     * * `currency` - Optional currency code (e.g., "SAT")
     * * `metadata_json` - Optional JSON metadata
     *
     * # Returns
     *
     * JSON message to send over Noise channel.
     */
    func createPaymentRequest(payer: String, payee: String, methodId: String, amount: String?, currency: String?, metadataJson: String?) throws  -> String
    
    /**
     * Get a private endpoint for a peer.
     */
    func getPrivateEndpoint(peer: String, methodId: String) throws  -> PrivateEndpointOffer?
    
    /**
     * Get a receipt by ID.
     */
    func getReceipt(receiptId: String) throws  -> ReceiptRequest?
    
    /**
     * Get the receipt store.
     */
    func getStore()  -> ReceiptStore
    
    /**
     * Handle an incoming message from a peer.
     *
     * This processes a JSON message received over a Noise channel and returns
     * an optional response to send back.
     *
     * # Arguments
     *
     * * `message_json` - The JSON-encoded message from the Noise channel
     * * `peer_pubkey` - The public key of the peer who sent the message
     * * `my_pubkey` - Your own public key
     *
     * # Returns
     *
     * Optional JSON response to send back over the Noise channel.
     * Returns `None` for messages that don't require a response (e.g., Ack).
     *
     * # Example
     *
     * ```ignore
     * // In Swift/Kotlin
     * let response = manager.handleMessage(messageJson, peerPubkey, myPubkey)
     * if let responseJson = response {
     * noiseChannel.send(responseJson)
     * }
     * ```
     */
    func handleMessage(messageJson: String, peerPubkey: String, myPubkey: String) throws  -> String?
    
    /**
     * Handle a payment confirmation response.
     *
     * Call this when you receive a response to your payment request.
     * It validates the response and saves the confirmed receipt.
     *
     * # Arguments
     *
     * * `response_json` - The JSON response from the Noise channel
     * * `original_receipt_id` - The receipt ID from your original request
     *
     * # Returns
     *
     * The confirmed receipt if successful, or an error.
     */
    func handlePaymentResponse(responseJson: String, originalReceiptId: String) throws  -> ReceiptRequest
    
    /**
     * List all private endpoints for a peer.
     */
    func listPrivateEndpoints(peer: String) throws  -> [PrivateEndpointOffer]
    
    /**
     * List all receipts.
     */
    func listReceipts() throws  -> [ReceiptRequest]
    
    /**
     * Set the receipt generator callback.
     *
     * This must be called before handling receipt requests.
     *
     * # Arguments
     *
     * * `generator` - Callback for generating receipts (implement in Swift/Kotlin)
     *
     * # Errors
     *
     * Returns an error if the internal lock is poisoned.
     */
    func setGenerator(generator: ReceiptGeneratorCallback) throws 
    
}
/**
 * FFI wrapper for PaykitInteractiveManager.
 *
 * This provides a high-level interface for managing interactive payment flows
 * over Noise channels. Mobile apps use this to:
 *
 * 1. Process incoming messages and generate responses
 * 2. Initiate payment flows
 * 3. Manage receipts and private endpoints
 *
 * # Thread Safety
 *
 * This type is thread-safe and can be used from multiple threads.
 */
open class PaykitInteractiveManagerFfi: PaykitInteractiveManagerFfiProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_paykit_mobile_fn_clone_paykitinteractivemanagerffi(self.pointer, $0) }
    }
    /**
     * Create a new interactive manager without a generator.
     *
     * Use `set_generator` to set the receipt generator callback.
     *
     * # Arguments
     *
     * * `store` - Receipt store for persistence
     */
public convenience init(store: ReceiptStore) {
    let pointer =
        try! rustCall() {
    uniffi_paykit_mobile_fn_constructor_paykitinteractivemanagerffi_new(
        FfiConverterTypeReceiptStore_lower(store),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_paykit_mobile_fn_free_paykitinteractivemanagerffi(pointer, $0) }
    }

    

    
    /**
     * Create a private endpoint offer message.
     *
     * Use this to offer a private payment endpoint to a peer.
     *
     * # Arguments
     *
     * * `method_id` - Payment method (e.g., "lightning")
     * * `endpoint` - The endpoint to offer (e.g., Lightning invoice)
     *
     * # Returns
     *
     * JSON message to send over Noise channel.
     */
open func createEndpointOffer(methodId: String, endpoint: String)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_create_endpoint_offer(self.uniffiClonePointer(),
        FfiConverterString.lower(methodId),
        FfiConverterString.lower(endpoint),$0
    )
})
}
    
    /**
     * Create a payment request message to initiate a payment flow.
     *
     * Use this to create the initial message for requesting payment from a peer.
     *
     * # Arguments
     *
     * * `payer` - Your public key (the one paying)
     * * `payee` - The recipient's public key
     * * `method_id` - Payment method (e.g., "lightning", "onchain")
     * * `amount` - Optional amount (as string, e.g., "1000")
     * * `currency` - Optional currency code (e.g., "SAT")
     * * `metadata_json` - Optional JSON metadata
     *
     * # Returns
     *
     * JSON message to send over Noise channel.
     */
open func createPaymentRequest(payer: String, payee: String, methodId: String, amount: String?, currency: String?, metadataJson: String?)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_create_payment_request(self.uniffiClonePointer(),
        FfiConverterString.lower(payer),
        FfiConverterString.lower(payee),
        FfiConverterString.lower(methodId),
        FfiConverterOptionString.lower(amount),
        FfiConverterOptionString.lower(currency),
        FfiConverterOptionString.lower(metadataJson),$0
    )
})
}
    
    /**
     * Get a private endpoint for a peer.
     */
open func getPrivateEndpoint(peer: String, methodId: String)throws  -> PrivateEndpointOffer?  {
    return try  FfiConverterOptionTypePrivateEndpointOffer.lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_get_private_endpoint(self.uniffiClonePointer(),
        FfiConverterString.lower(peer),
        FfiConverterString.lower(methodId),$0
    )
})
}
    
    /**
     * Get a receipt by ID.
     */
open func getReceipt(receiptId: String)throws  -> ReceiptRequest?  {
    return try  FfiConverterOptionTypeReceiptRequest.lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_get_receipt(self.uniffiClonePointer(),
        FfiConverterString.lower(receiptId),$0
    )
})
}
    
    /**
     * Get the receipt store.
     */
open func getStore() -> ReceiptStore  {
    return try!  FfiConverterTypeReceiptStore_lift(try! rustCall() {
    uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_get_store(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Handle an incoming message from a peer.
     *
     * This processes a JSON message received over a Noise channel and returns
     * an optional response to send back.
     *
     * # Arguments
     *
     * * `message_json` - The JSON-encoded message from the Noise channel
     * * `peer_pubkey` - The public key of the peer who sent the message
     * * `my_pubkey` - Your own public key
     *
     * # Returns
     *
     * Optional JSON response to send back over the Noise channel.
     * Returns `None` for messages that don't require a response (e.g., Ack).
     *
     * # Example
     *
     * ```ignore
     * // In Swift/Kotlin
     * let response = manager.handleMessage(messageJson, peerPubkey, myPubkey)
     * if let responseJson = response {
     * noiseChannel.send(responseJson)
     * }
     * ```
     */
open func handleMessage(messageJson: String, peerPubkey: String, myPubkey: String)throws  -> String?  {
    return try  FfiConverterOptionString.lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_handle_message(self.uniffiClonePointer(),
        FfiConverterString.lower(messageJson),
        FfiConverterString.lower(peerPubkey),
        FfiConverterString.lower(myPubkey),$0
    )
})
}
    
    /**
     * Handle a payment confirmation response.
     *
     * Call this when you receive a response to your payment request.
     * It validates the response and saves the confirmed receipt.
     *
     * # Arguments
     *
     * * `response_json` - The JSON response from the Noise channel
     * * `original_receipt_id` - The receipt ID from your original request
     *
     * # Returns
     *
     * The confirmed receipt if successful, or an error.
     */
open func handlePaymentResponse(responseJson: String, originalReceiptId: String)throws  -> ReceiptRequest  {
    return try  FfiConverterTypeReceiptRequest_lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_handle_payment_response(self.uniffiClonePointer(),
        FfiConverterString.lower(responseJson),
        FfiConverterString.lower(originalReceiptId),$0
    )
})
}
    
    /**
     * List all private endpoints for a peer.
     */
open func listPrivateEndpoints(peer: String)throws  -> [PrivateEndpointOffer]  {
    return try  FfiConverterSequenceTypePrivateEndpointOffer.lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_list_private_endpoints(self.uniffiClonePointer(),
        FfiConverterString.lower(peer),$0
    )
})
}
    
    /**
     * List all receipts.
     */
open func listReceipts()throws  -> [ReceiptRequest]  {
    return try  FfiConverterSequenceTypeReceiptRequest.lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_list_receipts(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Set the receipt generator callback.
     *
     * This must be called before handling receipt requests.
     *
     * # Arguments
     *
     * * `generator` - Callback for generating receipts (implement in Swift/Kotlin)
     *
     * # Errors
     *
     * Returns an error if the internal lock is poisoned.
     */
open func setGenerator(generator: ReceiptGeneratorCallback)throws   {try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitinteractivemanagerffi_set_generator(self.uniffiClonePointer(),
        FfiConverterCallbackInterfaceReceiptGeneratorCallback_lower(generator),$0
    )
}
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaykitInteractiveManagerFFI: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PaykitInteractiveManagerFfi

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PaykitInteractiveManagerFfi {
        return PaykitInteractiveManagerFfi(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PaykitInteractiveManagerFfi) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaykitInteractiveManagerFfi {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PaykitInteractiveManagerFfi, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaykitInteractiveManagerFFI_lift(_ pointer: UnsafeMutableRawPointer) throws -> PaykitInteractiveManagerFfi {
    return try FfiConverterTypePaykitInteractiveManagerFFI.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaykitInteractiveManagerFFI_lower(_ value: PaykitInteractiveManagerFfi) -> UnsafeMutableRawPointer {
    return FfiConverterTypePaykitInteractiveManagerFFI.lower(value)
}






/**
 * Builder for creating Paykit protocol messages.
 *
 * Use this to create JSON messages for sending over Noise channels.
 */
public protocol PaykitMessageBuilderProtocol: AnyObject, Sendable {
    
    /**
     * Create an acknowledgment message.
     *
     * # Returns
     *
     * JSON-encoded message ready to send over Noise channel.
     */
    func createAck() throws  -> String
    
    /**
     * Create an endpoint offer message.
     *
     * # Arguments
     *
     * * `method_id` - Payment method identifier (e.g., "lightning", "onchain")
     * * `endpoint` - The endpoint to offer (e.g., Lightning invoice, Bitcoin address)
     *
     * # Returns
     *
     * JSON-encoded message ready to send over Noise channel.
     */
    func createEndpointOffer(methodId: String, endpoint: String) throws  -> String
    
    /**
     * Create an error message.
     *
     * # Arguments
     *
     * * `code` - Error code
     * * `message` - Error message
     *
     * # Returns
     *
     * JSON-encoded message ready to send over Noise channel.
     */
    func createError(code: String, message: String) throws  -> String
    
    /**
     * Create a receipt confirmation message.
     *
     * # Arguments
     *
     * * `receipt` - The confirmed receipt details
     *
     * # Returns
     *
     * JSON-encoded message ready to send over Noise channel.
     */
    func createReceiptConfirm(receipt: ReceiptRequest) throws  -> String
    
    /**
     * Create a receipt request message.
     *
     * # Arguments
     *
     * * `request` - The receipt request details
     *
     * # Returns
     *
     * JSON-encoded message ready to send over Noise channel.
     */
    func createReceiptRequest(request: ReceiptRequest) throws  -> String
    
    /**
     * Get the message type from a JSON message.
     *
     * # Arguments
     *
     * * `message_json` - JSON-encoded message
     *
     * # Returns
     *
     * The message type.
     */
    func getMessageType(messageJson: String) throws  -> PaykitMessageType
    
    /**
     * Parse a received message.
     *
     * # Arguments
     *
     * * `message_json` - JSON-encoded message from Noise channel
     *
     * # Returns
     *
     * Parsed message for processing.
     */
    func parseMessage(messageJson: String) throws  -> ParsedMessage
    
}
/**
 * Builder for creating Paykit protocol messages.
 *
 * Use this to create JSON messages for sending over Noise channels.
 */
open class PaykitMessageBuilder: PaykitMessageBuilderProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_paykit_mobile_fn_clone_paykitmessagebuilder(self.pointer, $0) }
    }
    /**
     * Create a new message builder.
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_paykit_mobile_fn_constructor_paykitmessagebuilder_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_paykit_mobile_fn_free_paykitmessagebuilder(pointer, $0) }
    }

    

    
    /**
     * Create an acknowledgment message.
     *
     * # Returns
     *
     * JSON-encoded message ready to send over Noise channel.
     */
open func createAck()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitmessagebuilder_create_ack(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Create an endpoint offer message.
     *
     * # Arguments
     *
     * * `method_id` - Payment method identifier (e.g., "lightning", "onchain")
     * * `endpoint` - The endpoint to offer (e.g., Lightning invoice, Bitcoin address)
     *
     * # Returns
     *
     * JSON-encoded message ready to send over Noise channel.
     */
open func createEndpointOffer(methodId: String, endpoint: String)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitmessagebuilder_create_endpoint_offer(self.uniffiClonePointer(),
        FfiConverterString.lower(methodId),
        FfiConverterString.lower(endpoint),$0
    )
})
}
    
    /**
     * Create an error message.
     *
     * # Arguments
     *
     * * `code` - Error code
     * * `message` - Error message
     *
     * # Returns
     *
     * JSON-encoded message ready to send over Noise channel.
     */
open func createError(code: String, message: String)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitmessagebuilder_create_error(self.uniffiClonePointer(),
        FfiConverterString.lower(code),
        FfiConverterString.lower(message),$0
    )
})
}
    
    /**
     * Create a receipt confirmation message.
     *
     * # Arguments
     *
     * * `receipt` - The confirmed receipt details
     *
     * # Returns
     *
     * JSON-encoded message ready to send over Noise channel.
     */
open func createReceiptConfirm(receipt: ReceiptRequest)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitmessagebuilder_create_receipt_confirm(self.uniffiClonePointer(),
        FfiConverterTypeReceiptRequest_lower(receipt),$0
    )
})
}
    
    /**
     * Create a receipt request message.
     *
     * # Arguments
     *
     * * `request` - The receipt request details
     *
     * # Returns
     *
     * JSON-encoded message ready to send over Noise channel.
     */
open func createReceiptRequest(request: ReceiptRequest)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitmessagebuilder_create_receipt_request(self.uniffiClonePointer(),
        FfiConverterTypeReceiptRequest_lower(request),$0
    )
})
}
    
    /**
     * Get the message type from a JSON message.
     *
     * # Arguments
     *
     * * `message_json` - JSON-encoded message
     *
     * # Returns
     *
     * The message type.
     */
open func getMessageType(messageJson: String)throws  -> PaykitMessageType  {
    return try  FfiConverterTypePaykitMessageType_lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitmessagebuilder_get_message_type(self.uniffiClonePointer(),
        FfiConverterString.lower(messageJson),$0
    )
})
}
    
    /**
     * Parse a received message.
     *
     * # Arguments
     *
     * * `message_json` - JSON-encoded message from Noise channel
     *
     * # Returns
     *
     * Parsed message for processing.
     */
open func parseMessage(messageJson: String)throws  -> ParsedMessage  {
    return try  FfiConverterTypeParsedMessage_lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_paykitmessagebuilder_parse_message(self.uniffiClonePointer(),
        FfiConverterString.lower(messageJson),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaykitMessageBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PaykitMessageBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PaykitMessageBuilder {
        return PaykitMessageBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PaykitMessageBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaykitMessageBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PaykitMessageBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaykitMessageBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> PaykitMessageBuilder {
    return try FfiConverterTypePaykitMessageBuilder.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaykitMessageBuilder_lower(_ value: PaykitMessageBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypePaykitMessageBuilder.lower(value)
}






/**
 * In-memory receipt storage for mobile.
 *
 * Stores receipts during a session. For persistence, mobile apps should
 * save receipts to their own storage (Keychain/SharedPreferences).
 */
public protocol ReceiptStoreProtocol: AnyObject, Sendable {
    
    /**
     * Clear all stored data.
     */
    func clear() throws 
    
    /**
     * Delete a receipt.
     */
    func deleteReceipt(receiptId: String) throws 
    
    /**
     * Export all receipts as JSON.
     */
    func exportReceiptsJson() throws  -> String
    
    /**
     * Get a private endpoint.
     */
    func getPrivateEndpoint(peer: String, methodId: String) throws  -> PrivateEndpointOffer?
    
    /**
     * Get a receipt by ID.
     */
    func getReceipt(receiptId: String) throws  -> ReceiptRequest?
    
    /**
     * Import receipts from JSON.
     */
    func importReceiptsJson(json: String) throws  -> UInt32
    
    /**
     * List all private endpoints for a peer.
     */
    func listPrivateEndpoints(peer: String) throws  -> [PrivateEndpointOffer]
    
    /**
     * List all receipts.
     */
    func listReceipts() throws  -> [ReceiptRequest]
    
    /**
     * Save a private endpoint.
     */
    func savePrivateEndpoint(peer: String, offer: PrivateEndpointOffer) throws 
    
    /**
     * Save a receipt.
     */
    func saveReceipt(receipt: ReceiptRequest) throws 
    
}
/**
 * In-memory receipt storage for mobile.
 *
 * Stores receipts during a session. For persistence, mobile apps should
 * save receipts to their own storage (Keychain/SharedPreferences).
 */
open class ReceiptStore: ReceiptStoreProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_paykit_mobile_fn_clone_receiptstore(self.pointer, $0) }
    }
    /**
     * Create a new receipt store.
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_paykit_mobile_fn_constructor_receiptstore_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_paykit_mobile_fn_free_receiptstore(pointer, $0) }
    }

    

    
    /**
     * Clear all stored data.
     */
open func clear()throws   {try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_receiptstore_clear(self.uniffiClonePointer(),$0
    )
}
}
    
    /**
     * Delete a receipt.
     */
open func deleteReceipt(receiptId: String)throws   {try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_receiptstore_delete_receipt(self.uniffiClonePointer(),
        FfiConverterString.lower(receiptId),$0
    )
}
}
    
    /**
     * Export all receipts as JSON.
     */
open func exportReceiptsJson()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_receiptstore_export_receipts_json(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get a private endpoint.
     */
open func getPrivateEndpoint(peer: String, methodId: String)throws  -> PrivateEndpointOffer?  {
    return try  FfiConverterOptionTypePrivateEndpointOffer.lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_receiptstore_get_private_endpoint(self.uniffiClonePointer(),
        FfiConverterString.lower(peer),
        FfiConverterString.lower(methodId),$0
    )
})
}
    
    /**
     * Get a receipt by ID.
     */
open func getReceipt(receiptId: String)throws  -> ReceiptRequest?  {
    return try  FfiConverterOptionTypeReceiptRequest.lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_receiptstore_get_receipt(self.uniffiClonePointer(),
        FfiConverterString.lower(receiptId),$0
    )
})
}
    
    /**
     * Import receipts from JSON.
     */
open func importReceiptsJson(json: String)throws  -> UInt32  {
    return try  FfiConverterUInt32.lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_receiptstore_import_receipts_json(self.uniffiClonePointer(),
        FfiConverterString.lower(json),$0
    )
})
}
    
    /**
     * List all private endpoints for a peer.
     */
open func listPrivateEndpoints(peer: String)throws  -> [PrivateEndpointOffer]  {
    return try  FfiConverterSequenceTypePrivateEndpointOffer.lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_receiptstore_list_private_endpoints(self.uniffiClonePointer(),
        FfiConverterString.lower(peer),$0
    )
})
}
    
    /**
     * List all receipts.
     */
open func listReceipts()throws  -> [ReceiptRequest]  {
    return try  FfiConverterSequenceTypeReceiptRequest.lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_receiptstore_list_receipts(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Save a private endpoint.
     */
open func savePrivateEndpoint(peer: String, offer: PrivateEndpointOffer)throws   {try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_receiptstore_save_private_endpoint(self.uniffiClonePointer(),
        FfiConverterString.lower(peer),
        FfiConverterTypePrivateEndpointOffer_lower(offer),$0
    )
}
}
    
    /**
     * Save a receipt.
     */
open func saveReceipt(receipt: ReceiptRequest)throws   {try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_receiptstore_save_receipt(self.uniffiClonePointer(),
        FfiConverterTypeReceiptRequest_lower(receipt),$0
    )
}
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeReceiptStore: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ReceiptStore

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ReceiptStore {
        return ReceiptStore(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ReceiptStore) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReceiptStore {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ReceiptStore, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReceiptStore_lift(_ pointer: UnsafeMutableRawPointer) throws -> ReceiptStore {
    return try FfiConverterTypeReceiptStore.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReceiptStore_lower(_ value: ReceiptStore) -> UnsafeMutableRawPointer {
    return FfiConverterTypeReceiptStore.lower(value)
}






/**
 * Manager for atomic spending limit operations.
 *
 * This manager handles the reserve-commit-rollback pattern for spending limits,
 * ensuring thread-safe atomic operations during background auto-pay.
 */
public protocol SpendingManagerFfiProtocol: AnyObject, Sendable {
    
    /**
     * Get the number of active (in-flight) reservations.
     *
     * Useful for debugging and monitoring.
     */
    func activeReservationsCount()  -> UInt32
    
    /**
     * Commit a spending reservation after successful payment.
     *
     * This finalizes the reservation - the spent amount becomes permanent.
     * This operation is idempotent.
     *
     * # Arguments
     *
     * * `reservation_id` - The reservation ID from `try_reserve_spending()`
     */
    func commitSpending(reservationId: String) throws 
    
    /**
     * Get the current spending limit for a peer.
     *
     * # Arguments
     *
     * * `peer_pubkey` - Peer's public key (z-base32 encoded)
     *
     * # Returns
     *
     * The spending limit if one exists, None otherwise.
     */
    func getPeerSpendingLimit(peerPubkey: String) throws  -> PeerSpendingLimitFfi?
    
    /**
     * List all spending limits.
     *
     * # Returns
     *
     * List of all configured spending limits.
     */
    func listSpendingLimits() throws  -> [PeerSpendingLimitFfi]
    
    /**
     * Remove a spending limit for a peer.
     *
     * # Arguments
     *
     * * `peer_pubkey` - Peer's public key (z-base32 encoded)
     */
    func removePeerSpendingLimit(peerPubkey: String) throws 
    
    /**
     * Rollback a spending reservation after failed payment.
     *
     * This releases the reserved amount back to the limit.
     * This operation is idempotent.
     *
     * # Arguments
     *
     * * `reservation_id` - The reservation ID from `try_reserve_spending()`
     */
    func rollbackSpending(reservationId: String) throws 
    
    /**
     * Set a spending limit for a peer.
     *
     * # Arguments
     *
     * * `peer_pubkey` - Peer's public key (z-base32 encoded)
     * * `limit_sats` - Maximum spending limit in satoshis
     * * `period` - Reset period ("daily", "weekly", or "monthly")
     *
     * # Example
     *
     * ```ignore
     * manager.set_peer_spending_limit(
     * "8pinxxgqs41...",
     * 100000,  // 100,000 sats
     * "monthly"
     * )?;
     * ```
     */
    func setPeerSpendingLimit(peerPubkey: String, limitSats: Int64, period: String) throws  -> PeerSpendingLimitFfi
    
    /**
     * Try to reserve spending amount atomically.
     *
     * This method performs an atomic check-and-reserve operation:
     * 1. Acquires exclusive file lock
     * 2. Checks if amount would exceed limit
     * 3. If within limit, reserves the amount
     * 4. Returns a reservation token
     *
     * The reservation MUST be either committed or rolled back after payment.
     *
     * # Arguments
     *
     * * `peer_pubkey` - Peer's public key
     * * `amount_sats` - Amount to reserve in satoshis
     *
     * # Errors
     *
     * - `NotFound` if no spending limit is set for this peer
     * - `Validation` with "Limit exceeded" if amount would exceed limit
     *
     * # Example
     *
     * ```ignore
     * let reservation = manager.try_reserve_spending("8pinxxgqs41...", 10000)?;
     * // Execute payment...
     * manager.commit_spending(reservation.reservation_id)?;
     * ```
     */
    func tryReserveSpending(peerPubkey: String, amountSats: Int64) throws  -> SpendingReservationFfi
    
    /**
     * Check if an amount would exceed the spending limit (non-blocking check).
     *
     * This is a read-only check that does not modify the spending limit.
     * For actual payment execution, use `try_reserve_spending()` instead.
     *
     * # Arguments
     *
     * * `peer_pubkey` - Peer's public key
     * * `amount_sats` - Amount to check in satoshis
     *
     * # Returns
     *
     * A result containing whether the amount would exceed the limit.
     */
    func wouldExceedSpendingLimit(peerPubkey: String, amountSats: Int64) throws  -> SpendingCheckResultFfi
    
}
/**
 * Manager for atomic spending limit operations.
 *
 * This manager handles the reserve-commit-rollback pattern for spending limits,
 * ensuring thread-safe atomic operations during background auto-pay.
 */
open class SpendingManagerFfi: SpendingManagerFfiProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_paykit_mobile_fn_clone_spendingmanagerffi(self.pointer, $0) }
    }
    /**
     * Create a new spending manager with the given storage path.
     *
     * # Arguments
     *
     * * `storage_path` - Path to the storage directory for spending limits
     */
public convenience init(storagePath: String)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_constructor_spendingmanagerffi_new(
        FfiConverterString.lower(storagePath),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_paykit_mobile_fn_free_spendingmanagerffi(pointer, $0) }
    }

    

    
    /**
     * Get the number of active (in-flight) reservations.
     *
     * Useful for debugging and monitoring.
     */
open func activeReservationsCount() -> UInt32  {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_paykit_mobile_fn_method_spendingmanagerffi_active_reservations_count(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Commit a spending reservation after successful payment.
     *
     * This finalizes the reservation - the spent amount becomes permanent.
     * This operation is idempotent.
     *
     * # Arguments
     *
     * * `reservation_id` - The reservation ID from `try_reserve_spending()`
     */
open func commitSpending(reservationId: String)throws   {try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_spendingmanagerffi_commit_spending(self.uniffiClonePointer(),
        FfiConverterString.lower(reservationId),$0
    )
}
}
    
    /**
     * Get the current spending limit for a peer.
     *
     * # Arguments
     *
     * * `peer_pubkey` - Peer's public key (z-base32 encoded)
     *
     * # Returns
     *
     * The spending limit if one exists, None otherwise.
     */
open func getPeerSpendingLimit(peerPubkey: String)throws  -> PeerSpendingLimitFfi?  {
    return try  FfiConverterOptionTypePeerSpendingLimitFFI.lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_spendingmanagerffi_get_peer_spending_limit(self.uniffiClonePointer(),
        FfiConverterString.lower(peerPubkey),$0
    )
})
}
    
    /**
     * List all spending limits.
     *
     * # Returns
     *
     * List of all configured spending limits.
     */
open func listSpendingLimits()throws  -> [PeerSpendingLimitFfi]  {
    return try  FfiConverterSequenceTypePeerSpendingLimitFFI.lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_spendingmanagerffi_list_spending_limits(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Remove a spending limit for a peer.
     *
     * # Arguments
     *
     * * `peer_pubkey` - Peer's public key (z-base32 encoded)
     */
open func removePeerSpendingLimit(peerPubkey: String)throws   {try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_spendingmanagerffi_remove_peer_spending_limit(self.uniffiClonePointer(),
        FfiConverterString.lower(peerPubkey),$0
    )
}
}
    
    /**
     * Rollback a spending reservation after failed payment.
     *
     * This releases the reserved amount back to the limit.
     * This operation is idempotent.
     *
     * # Arguments
     *
     * * `reservation_id` - The reservation ID from `try_reserve_spending()`
     */
open func rollbackSpending(reservationId: String)throws   {try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_spendingmanagerffi_rollback_spending(self.uniffiClonePointer(),
        FfiConverterString.lower(reservationId),$0
    )
}
}
    
    /**
     * Set a spending limit for a peer.
     *
     * # Arguments
     *
     * * `peer_pubkey` - Peer's public key (z-base32 encoded)
     * * `limit_sats` - Maximum spending limit in satoshis
     * * `period` - Reset period ("daily", "weekly", or "monthly")
     *
     * # Example
     *
     * ```ignore
     * manager.set_peer_spending_limit(
     * "8pinxxgqs41...",
     * 100000,  // 100,000 sats
     * "monthly"
     * )?;
     * ```
     */
open func setPeerSpendingLimit(peerPubkey: String, limitSats: Int64, period: String)throws  -> PeerSpendingLimitFfi  {
    return try  FfiConverterTypePeerSpendingLimitFFI_lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_spendingmanagerffi_set_peer_spending_limit(self.uniffiClonePointer(),
        FfiConverterString.lower(peerPubkey),
        FfiConverterInt64.lower(limitSats),
        FfiConverterString.lower(period),$0
    )
})
}
    
    /**
     * Try to reserve spending amount atomically.
     *
     * This method performs an atomic check-and-reserve operation:
     * 1. Acquires exclusive file lock
     * 2. Checks if amount would exceed limit
     * 3. If within limit, reserves the amount
     * 4. Returns a reservation token
     *
     * The reservation MUST be either committed or rolled back after payment.
     *
     * # Arguments
     *
     * * `peer_pubkey` - Peer's public key
     * * `amount_sats` - Amount to reserve in satoshis
     *
     * # Errors
     *
     * - `NotFound` if no spending limit is set for this peer
     * - `Validation` with "Limit exceeded" if amount would exceed limit
     *
     * # Example
     *
     * ```ignore
     * let reservation = manager.try_reserve_spending("8pinxxgqs41...", 10000)?;
     * // Execute payment...
     * manager.commit_spending(reservation.reservation_id)?;
     * ```
     */
open func tryReserveSpending(peerPubkey: String, amountSats: Int64)throws  -> SpendingReservationFfi  {
    return try  FfiConverterTypeSpendingReservationFFI_lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_spendingmanagerffi_try_reserve_spending(self.uniffiClonePointer(),
        FfiConverterString.lower(peerPubkey),
        FfiConverterInt64.lower(amountSats),$0
    )
})
}
    
    /**
     * Check if an amount would exceed the spending limit (non-blocking check).
     *
     * This is a read-only check that does not modify the spending limit.
     * For actual payment execution, use `try_reserve_spending()` instead.
     *
     * # Arguments
     *
     * * `peer_pubkey` - Peer's public key
     * * `amount_sats` - Amount to check in satoshis
     *
     * # Returns
     *
     * A result containing whether the amount would exceed the limit.
     */
open func wouldExceedSpendingLimit(peerPubkey: String, amountSats: Int64)throws  -> SpendingCheckResultFfi  {
    return try  FfiConverterTypeSpendingCheckResultFFI_lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_spendingmanagerffi_would_exceed_spending_limit(self.uniffiClonePointer(),
        FfiConverterString.lower(peerPubkey),
        FfiConverterInt64.lower(amountSats),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSpendingManagerFFI: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SpendingManagerFfi

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SpendingManagerFfi {
        return SpendingManagerFfi(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SpendingManagerFfi) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SpendingManagerFfi {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SpendingManagerFfi, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSpendingManagerFFI_lift(_ pointer: UnsafeMutableRawPointer) throws -> SpendingManagerFfi {
    return try FfiConverterTypeSpendingManagerFFI.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSpendingManagerFFI_lower(_ value: SpendingManagerFfi) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSpendingManagerFFI.lower(value)
}






/**
 * FFI wrapper for unauthenticated (read-only) transport operations.
 *
 * This wraps read-only access to public Pubky storage.
 * Mobile apps can use this to discover payment methods for other users.
 *
 * # Creating in Production
 *
 * Implement `PubkyUnauthenticatedStorageCallback` in Swift/Kotlin:
 *
 * ```swift
 * class MyPublicStorage: PubkyUnauthenticatedStorageCallback {
 * func get(ownerPubkey: String, path: String) -> StorageGetResult {
 * // Use Pubky SDK to read from public storage
 * let url = "pubky://\(ownerPubkey)\(path)"
 * if let content = try? pubkyClient.get(url) {
 * return StorageGetResult.ok(content: content)
 * }
 * return StorageGetResult.ok(content: nil) // Not found
 * }
 *
 * func list(ownerPubkey: String, prefix: String) -> StorageListResult {
 * // ... implement using Pubky SDK
 * }
 * }
 *
 * let transport = UnauthenticatedTransportFFI.fromCallback(MyPublicStorage())
 * ```
 */
public protocol UnauthenticatedTransportFfiProtocol: AnyObject, Sendable {
    
    /**
     * Get a file at the given path from a public key's storage.
     */
    func get(ownerPubkey: String, path: String) throws  -> String?
    
    /**
     * Check if this transport uses a real callback (production) or mock storage.
     *
     * Returns `true` for mock transport, `false` for callback-based transport.
     * Returns an error if the internal lock is poisoned.
     */
    func isMock() throws  -> Bool
    
    /**
     * List files with a given prefix from a public key's storage.
     */
    func list(ownerPubkey: String, prefix: String) throws  -> [String]
    
}
/**
 * FFI wrapper for unauthenticated (read-only) transport operations.
 *
 * This wraps read-only access to public Pubky storage.
 * Mobile apps can use this to discover payment methods for other users.
 *
 * # Creating in Production
 *
 * Implement `PubkyUnauthenticatedStorageCallback` in Swift/Kotlin:
 *
 * ```swift
 * class MyPublicStorage: PubkyUnauthenticatedStorageCallback {
 * func get(ownerPubkey: String, path: String) -> StorageGetResult {
 * // Use Pubky SDK to read from public storage
 * let url = "pubky://\(ownerPubkey)\(path)"
 * if let content = try? pubkyClient.get(url) {
 * return StorageGetResult.ok(content: content)
 * }
 * return StorageGetResult.ok(content: nil) // Not found
 * }
 *
 * func list(ownerPubkey: String, prefix: String) -> StorageListResult {
 * // ... implement using Pubky SDK
 * }
 * }
 *
 * let transport = UnauthenticatedTransportFFI.fromCallback(MyPublicStorage())
 * ```
 */
open class UnauthenticatedTransportFfi: UnauthenticatedTransportFfiProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_paykit_mobile_fn_clone_unauthenticatedtransportffi(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_paykit_mobile_fn_free_unauthenticatedtransportffi(pointer, $0) }
    }

    
    /**
     * Create unauthenticated transport that shares mock storage with an authenticated transport.
     *
     * Useful for testing when you want reads to see writes from the same session.
     *
     * # Note
     *
     * This only works with mock transports. For callback-based transports,
     * create a new `UnauthenticatedTransportFFI::from_callback()` that shares
     * the underlying Pubky client.
     */
public static func fromAuthenticated(auth: AuthenticatedTransportFfi)throws  -> UnauthenticatedTransportFfi  {
    return try  FfiConverterTypeUnauthenticatedTransportFFI_lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_constructor_unauthenticatedtransportffi_from_authenticated(
        FfiConverterTypeAuthenticatedTransportFFI_lower(auth),$0
    )
})
}
    
    /**
     * Create unauthenticated transport from a storage callback.
     *
     * # Arguments
     *
     * * `callback` - Storage callback implementing PubkyUnauthenticatedStorageCallback
     *
     * # Example (Swift)
     *
     * ```swift
     * class MyPublicStorage: PubkyUnauthenticatedStorageCallback {
     * func get(ownerPubkey: String, path: String) -> StorageGetResult {
     * // Use Pubky SDK to read from public storage
     * // ...
     * }
     * }
     *
     * let transport = UnauthenticatedTransportFFI.fromCallback(MyPublicStorage())
     * ```
     */
public static func fromCallback(callback: PubkyUnauthenticatedStorageCallback) -> UnauthenticatedTransportFfi  {
    return try!  FfiConverterTypeUnauthenticatedTransportFFI_lift(try! rustCall() {
    uniffi_paykit_mobile_fn_constructor_unauthenticatedtransportffi_from_callback(
        FfiConverterCallbackInterfacePubkyUnauthenticatedStorageCallback_lower(callback),$0
    )
})
}
    
    /**
     * Create unauthenticated transport from Pubky SDK configuration.
     *
     * # Deprecated
     *
     * This method creates a mock transport. Use `from_callback()` for production.
     *
     * # Arguments
     *
     * * `config_json` - JSON configuration (validated but not used)
     */
public static func fromConfigJson(configJson: String)throws  -> UnauthenticatedTransportFfi  {
    return try  FfiConverterTypeUnauthenticatedTransportFFI_lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_constructor_unauthenticatedtransportffi_from_config_json(
        FfiConverterString.lower(configJson),$0
    )
})
}
    
    /**
     * Create a new unauthenticated transport for testing/development.
     *
     * Uses in-memory storage - no network calls are made.
     */
public static func newMock() -> UnauthenticatedTransportFfi  {
    return try!  FfiConverterTypeUnauthenticatedTransportFFI_lift(try! rustCall() {
    uniffi_paykit_mobile_fn_constructor_unauthenticatedtransportffi_new_mock($0
    )
})
}
    

    
    /**
     * Get a file at the given path from a public key's storage.
     */
open func get(ownerPubkey: String, path: String)throws  -> String?  {
    return try  FfiConverterOptionString.lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_unauthenticatedtransportffi_get(self.uniffiClonePointer(),
        FfiConverterString.lower(ownerPubkey),
        FfiConverterString.lower(path),$0
    )
})
}
    
    /**
     * Check if this transport uses a real callback (production) or mock storage.
     *
     * Returns `true` for mock transport, `false` for callback-based transport.
     * Returns an error if the internal lock is poisoned.
     */
open func isMock()throws  -> Bool  {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_unauthenticatedtransportffi_is_mock(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * List files with a given prefix from a public key's storage.
     */
open func list(ownerPubkey: String, prefix: String)throws  -> [String]  {
    return try  FfiConverterSequenceString.lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_method_unauthenticatedtransportffi_list(self.uniffiClonePointer(),
        FfiConverterString.lower(ownerPubkey),
        FfiConverterString.lower(prefix),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnauthenticatedTransportFFI: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = UnauthenticatedTransportFfi

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> UnauthenticatedTransportFfi {
        return UnauthenticatedTransportFfi(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: UnauthenticatedTransportFfi) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnauthenticatedTransportFfi {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: UnauthenticatedTransportFfi, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnauthenticatedTransportFFI_lift(_ pointer: UnsafeMutableRawPointer) throws -> UnauthenticatedTransportFfi {
    return try FfiConverterTypeUnauthenticatedTransportFFI.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnauthenticatedTransportFFI_lower(_ value: UnauthenticatedTransportFfi) -> UnsafeMutableRawPointer {
    return FfiConverterTypeUnauthenticatedTransportFFI.lower(value)
}




/**
 * Payment amount.
 */
public struct Amount {
    public var value: String
    public var currency: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: String, currency: String) {
        self.value = value
        self.currency = currency
    }
}

#if compiler(>=6)
extension Amount: Sendable {}
#endif


extension Amount: Equatable, Hashable {
    public static func ==(lhs: Amount, rhs: Amount) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        if lhs.currency != rhs.currency {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
        hasher.combine(currency)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAmount: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Amount {
        return
            try Amount(
                value: FfiConverterString.read(from: &buf), 
                currency: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Amount, into buf: inout [UInt8]) {
        FfiConverterString.write(value.value, into: &buf)
        FfiConverterString.write(value.currency, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAmount_lift(_ buf: RustBuffer) throws -> Amount {
    return try FfiConverterTypeAmount.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAmount_lower(_ value: Amount) -> RustBuffer {
    return FfiConverterTypeAmount.lower(value)
}


/**
 * Result of a Bitcoin on-chain transaction (FFI-compatible).
 *
 * This type is returned by `BitcoinExecutorFFI::sendToAddress()` after
 * successfully broadcasting a transaction.
 */
public struct BitcoinTxResultFfi {
    /**
     * The transaction ID (hex-encoded, 64 characters).
     */
    public var txid: String
    /**
     * The raw transaction hex (optional, for debugging/verification).
     */
    public var rawTx: String?
    /**
     * The output index used for payment.
     */
    public var vout: UInt32
    /**
     * The fee paid in satoshis.
     */
    public var feeSats: UInt64
    /**
     * The fee rate in sat/vB.
     */
    public var feeRate: Double
    /**
     * Block height if confirmed (None if unconfirmed).
     */
    public var blockHeight: UInt64?
    /**
     * Number of confirmations.
     */
    public var confirmations: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The transaction ID (hex-encoded, 64 characters).
         */txid: String, 
        /**
         * The raw transaction hex (optional, for debugging/verification).
         */rawTx: String?, 
        /**
         * The output index used for payment.
         */vout: UInt32, 
        /**
         * The fee paid in satoshis.
         */feeSats: UInt64, 
        /**
         * The fee rate in sat/vB.
         */feeRate: Double, 
        /**
         * Block height if confirmed (None if unconfirmed).
         */blockHeight: UInt64?, 
        /**
         * Number of confirmations.
         */confirmations: UInt64) {
        self.txid = txid
        self.rawTx = rawTx
        self.vout = vout
        self.feeSats = feeSats
        self.feeRate = feeRate
        self.blockHeight = blockHeight
        self.confirmations = confirmations
    }
}

#if compiler(>=6)
extension BitcoinTxResultFfi: Sendable {}
#endif


extension BitcoinTxResultFfi: Equatable, Hashable {
    public static func ==(lhs: BitcoinTxResultFfi, rhs: BitcoinTxResultFfi) -> Bool {
        if lhs.txid != rhs.txid {
            return false
        }
        if lhs.rawTx != rhs.rawTx {
            return false
        }
        if lhs.vout != rhs.vout {
            return false
        }
        if lhs.feeSats != rhs.feeSats {
            return false
        }
        if lhs.feeRate != rhs.feeRate {
            return false
        }
        if lhs.blockHeight != rhs.blockHeight {
            return false
        }
        if lhs.confirmations != rhs.confirmations {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(txid)
        hasher.combine(rawTx)
        hasher.combine(vout)
        hasher.combine(feeSats)
        hasher.combine(feeRate)
        hasher.combine(blockHeight)
        hasher.combine(confirmations)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBitcoinTxResultFFI: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BitcoinTxResultFfi {
        return
            try BitcoinTxResultFfi(
                txid: FfiConverterString.read(from: &buf), 
                rawTx: FfiConverterOptionString.read(from: &buf), 
                vout: FfiConverterUInt32.read(from: &buf), 
                feeSats: FfiConverterUInt64.read(from: &buf), 
                feeRate: FfiConverterDouble.read(from: &buf), 
                blockHeight: FfiConverterOptionUInt64.read(from: &buf), 
                confirmations: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: BitcoinTxResultFfi, into buf: inout [UInt8]) {
        FfiConverterString.write(value.txid, into: &buf)
        FfiConverterOptionString.write(value.rawTx, into: &buf)
        FfiConverterUInt32.write(value.vout, into: &buf)
        FfiConverterUInt64.write(value.feeSats, into: &buf)
        FfiConverterDouble.write(value.feeRate, into: &buf)
        FfiConverterOptionUInt64.write(value.blockHeight, into: &buf)
        FfiConverterUInt64.write(value.confirmations, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBitcoinTxResultFFI_lift(_ buf: RustBuffer) throws -> BitcoinTxResultFfi {
    return try FfiConverterTypeBitcoinTxResultFFI.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBitcoinTxResultFFI_lower(_ value: BitcoinTxResultFfi) -> RustBuffer {
    return FfiConverterTypeBitcoinTxResultFFI.lower(value)
}


/**
 * FFI-safe cached contact.
 */
public struct CachedContactFfi {
    public var pubkey: String
    public var name: String?
    public var addedAt: Int64
    public var lastSyncedAt: Int64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(pubkey: String, name: String?, addedAt: Int64, lastSyncedAt: Int64?) {
        self.pubkey = pubkey
        self.name = name
        self.addedAt = addedAt
        self.lastSyncedAt = lastSyncedAt
    }
}

#if compiler(>=6)
extension CachedContactFfi: Sendable {}
#endif


extension CachedContactFfi: Equatable, Hashable {
    public static func ==(lhs: CachedContactFfi, rhs: CachedContactFfi) -> Bool {
        if lhs.pubkey != rhs.pubkey {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.addedAt != rhs.addedAt {
            return false
        }
        if lhs.lastSyncedAt != rhs.lastSyncedAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(pubkey)
        hasher.combine(name)
        hasher.combine(addedAt)
        hasher.combine(lastSyncedAt)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCachedContactFFI: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CachedContactFfi {
        return
            try CachedContactFfi(
                pubkey: FfiConverterString.read(from: &buf), 
                name: FfiConverterOptionString.read(from: &buf), 
                addedAt: FfiConverterInt64.read(from: &buf), 
                lastSyncedAt: FfiConverterOptionInt64.read(from: &buf)
        )
    }

    public static func write(_ value: CachedContactFfi, into buf: inout [UInt8]) {
        FfiConverterString.write(value.pubkey, into: &buf)
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterInt64.write(value.addedAt, into: &buf)
        FfiConverterOptionInt64.write(value.lastSyncedAt, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCachedContactFFI_lift(_ buf: RustBuffer) throws -> CachedContactFfi {
    return try FfiConverterTypeCachedContactFFI.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCachedContactFFI_lower(_ value: CachedContactFfi) -> RustBuffer {
    return FfiConverterTypeCachedContactFFI.lower(value)
}


/**
 * Decoded BOLT11 invoice details (FFI-compatible).
 *
 * This type is returned by `LightningExecutorFFI::decodeInvoice()`.
 */
public struct DecodedInvoiceFfi {
    /**
     * The payment hash (hex-encoded).
     */
    public var paymentHash: String
    /**
     * Amount in millisatoshis (None for zero-amount invoices).
     */
    public var amountMsat: UInt64?
    /**
     * Invoice description.
     */
    public var description: String?
    /**
     * Description hash (for invoices with hashed descriptions).
     */
    public var descriptionHash: String?
    /**
     * Payee public key (hex-encoded).
     */
    public var payee: String
    /**
     * Expiry time in seconds.
     */
    public var expiry: UInt64
    /**
     * Creation timestamp (Unix epoch seconds).
     */
    public var timestamp: UInt64
    /**
     * Whether the invoice has expired.
     */
    public var expired: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The payment hash (hex-encoded).
         */paymentHash: String, 
        /**
         * Amount in millisatoshis (None for zero-amount invoices).
         */amountMsat: UInt64?, 
        /**
         * Invoice description.
         */description: String?, 
        /**
         * Description hash (for invoices with hashed descriptions).
         */descriptionHash: String?, 
        /**
         * Payee public key (hex-encoded).
         */payee: String, 
        /**
         * Expiry time in seconds.
         */expiry: UInt64, 
        /**
         * Creation timestamp (Unix epoch seconds).
         */timestamp: UInt64, 
        /**
         * Whether the invoice has expired.
         */expired: Bool) {
        self.paymentHash = paymentHash
        self.amountMsat = amountMsat
        self.description = description
        self.descriptionHash = descriptionHash
        self.payee = payee
        self.expiry = expiry
        self.timestamp = timestamp
        self.expired = expired
    }
}

#if compiler(>=6)
extension DecodedInvoiceFfi: Sendable {}
#endif


extension DecodedInvoiceFfi: Equatable, Hashable {
    public static func ==(lhs: DecodedInvoiceFfi, rhs: DecodedInvoiceFfi) -> Bool {
        if lhs.paymentHash != rhs.paymentHash {
            return false
        }
        if lhs.amountMsat != rhs.amountMsat {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.descriptionHash != rhs.descriptionHash {
            return false
        }
        if lhs.payee != rhs.payee {
            return false
        }
        if lhs.expiry != rhs.expiry {
            return false
        }
        if lhs.timestamp != rhs.timestamp {
            return false
        }
        if lhs.expired != rhs.expired {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentHash)
        hasher.combine(amountMsat)
        hasher.combine(description)
        hasher.combine(descriptionHash)
        hasher.combine(payee)
        hasher.combine(expiry)
        hasher.combine(timestamp)
        hasher.combine(expired)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDecodedInvoiceFFI: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DecodedInvoiceFfi {
        return
            try DecodedInvoiceFfi(
                paymentHash: FfiConverterString.read(from: &buf), 
                amountMsat: FfiConverterOptionUInt64.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                descriptionHash: FfiConverterOptionString.read(from: &buf), 
                payee: FfiConverterString.read(from: &buf), 
                expiry: FfiConverterUInt64.read(from: &buf), 
                timestamp: FfiConverterUInt64.read(from: &buf), 
                expired: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: DecodedInvoiceFfi, into buf: inout [UInt8]) {
        FfiConverterString.write(value.paymentHash, into: &buf)
        FfiConverterOptionUInt64.write(value.amountMsat, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.descriptionHash, into: &buf)
        FfiConverterString.write(value.payee, into: &buf)
        FfiConverterUInt64.write(value.expiry, into: &buf)
        FfiConverterUInt64.write(value.timestamp, into: &buf)
        FfiConverterBool.write(value.expired, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDecodedInvoiceFFI_lift(_ buf: RustBuffer) throws -> DecodedInvoiceFfi {
    return try FfiConverterTypeDecodedInvoiceFFI.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDecodedInvoiceFFI_lower(_ value: DecodedInvoiceFfi) -> RustBuffer {
    return FfiConverterTypeDecodedInvoiceFFI.lower(value)
}


/**
 * Generated Ed25519 keypair for identity.
 */
public struct Ed25519Keypair {
    /**
     * Secret key (seed) - 32 bytes, hex encoded.
     * SENSITIVE: Store securely, this is the root identity secret.
     */
    public var secretKeyHex: String
    /**
     * Public key - 32 bytes, hex encoded.
     */
    public var publicKeyHex: String
    /**
     * Public key in z-base32 format (pkarr format).
     */
    public var publicKeyZ32: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Secret key (seed) - 32 bytes, hex encoded.
         * SENSITIVE: Store securely, this is the root identity secret.
         */secretKeyHex: String, 
        /**
         * Public key - 32 bytes, hex encoded.
         */publicKeyHex: String, 
        /**
         * Public key in z-base32 format (pkarr format).
         */publicKeyZ32: String) {
        self.secretKeyHex = secretKeyHex
        self.publicKeyHex = publicKeyHex
        self.publicKeyZ32 = publicKeyZ32
    }
}

#if compiler(>=6)
extension Ed25519Keypair: Sendable {}
#endif


extension Ed25519Keypair: Equatable, Hashable {
    public static func ==(lhs: Ed25519Keypair, rhs: Ed25519Keypair) -> Bool {
        if lhs.secretKeyHex != rhs.secretKeyHex {
            return false
        }
        if lhs.publicKeyHex != rhs.publicKeyHex {
            return false
        }
        if lhs.publicKeyZ32 != rhs.publicKeyZ32 {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretKeyHex)
        hasher.combine(publicKeyHex)
        hasher.combine(publicKeyZ32)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEd25519Keypair: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Ed25519Keypair {
        return
            try Ed25519Keypair(
                secretKeyHex: FfiConverterString.read(from: &buf), 
                publicKeyHex: FfiConverterString.read(from: &buf), 
                publicKeyZ32: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Ed25519Keypair, into buf: inout [UInt8]) {
        FfiConverterString.write(value.secretKeyHex, into: &buf)
        FfiConverterString.write(value.publicKeyHex, into: &buf)
        FfiConverterString.write(value.publicKeyZ32, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEd25519Keypair_lift(_ buf: RustBuffer) throws -> Ed25519Keypair {
    return try FfiConverterTypeEd25519Keypair.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEd25519Keypair_lower(_ value: Ed25519Keypair) -> RustBuffer {
    return FfiConverterTypeEd25519Keypair.lower(value)
}


/**
 * Endpoint data for a payment method.
 */
public struct EndpointData {
    public var value: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: String) {
        self.value = value
    }
}

#if compiler(>=6)
extension EndpointData: Sendable {}
#endif


extension EndpointData: Equatable, Hashable {
    public static func ==(lhs: EndpointData, rhs: EndpointData) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEndpointData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EndpointData {
        return
            try EndpointData(
                value: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: EndpointData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEndpointData_lift(_ buf: RustBuffer) throws -> EndpointData {
    return try FfiConverterTypeEndpointData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEndpointData_lower(_ value: EndpointData) -> RustBuffer {
    return FfiConverterTypeEndpointData.lower(value)
}


/**
 * FFI-safe error message.
 */
public struct ErrorMessage {
    public var code: String
    public var message: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(code: String, message: String) {
        self.code = code
        self.message = message
    }
}

#if compiler(>=6)
extension ErrorMessage: Sendable {}
#endif


extension ErrorMessage: Equatable, Hashable {
    public static func ==(lhs: ErrorMessage, rhs: ErrorMessage) -> Bool {
        if lhs.code != rhs.code {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(code)
        hasher.combine(message)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeErrorMessage: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ErrorMessage {
        return
            try ErrorMessage(
                code: FfiConverterString.read(from: &buf), 
                message: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ErrorMessage, into buf: inout [UInt8]) {
        FfiConverterString.write(value.code, into: &buf)
        FfiConverterString.write(value.message, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeErrorMessage_lift(_ buf: RustBuffer) throws -> ErrorMessage {
    return try FfiConverterTypeErrorMessage.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeErrorMessage_lower(_ value: ErrorMessage) -> RustBuffer {
    return FfiConverterTypeErrorMessage.lower(value)
}


/**
 * Health check result.
 */
public struct HealthCheckResult {
    public var methodId: String
    public var status: HealthStatus
    public var checkedAt: Int64
    public var latencyMs: UInt64?
    public var error: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(methodId: String, status: HealthStatus, checkedAt: Int64, latencyMs: UInt64?, error: String?) {
        self.methodId = methodId
        self.status = status
        self.checkedAt = checkedAt
        self.latencyMs = latencyMs
        self.error = error
    }
}

#if compiler(>=6)
extension HealthCheckResult: Sendable {}
#endif


extension HealthCheckResult: Equatable, Hashable {
    public static func ==(lhs: HealthCheckResult, rhs: HealthCheckResult) -> Bool {
        if lhs.methodId != rhs.methodId {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.checkedAt != rhs.checkedAt {
            return false
        }
        if lhs.latencyMs != rhs.latencyMs {
            return false
        }
        if lhs.error != rhs.error {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(methodId)
        hasher.combine(status)
        hasher.combine(checkedAt)
        hasher.combine(latencyMs)
        hasher.combine(error)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHealthCheckResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HealthCheckResult {
        return
            try HealthCheckResult(
                methodId: FfiConverterString.read(from: &buf), 
                status: FfiConverterTypeHealthStatus.read(from: &buf), 
                checkedAt: FfiConverterInt64.read(from: &buf), 
                latencyMs: FfiConverterOptionUInt64.read(from: &buf), 
                error: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: HealthCheckResult, into buf: inout [UInt8]) {
        FfiConverterString.write(value.methodId, into: &buf)
        FfiConverterTypeHealthStatus.write(value.status, into: &buf)
        FfiConverterInt64.write(value.checkedAt, into: &buf)
        FfiConverterOptionUInt64.write(value.latencyMs, into: &buf)
        FfiConverterOptionString.write(value.error, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHealthCheckResult_lift(_ buf: RustBuffer) throws -> HealthCheckResult {
    return try FfiConverterTypeHealthCheckResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHealthCheckResult_lower(_ value: HealthCheckResult) -> RustBuffer {
    return FfiConverterTypeHealthCheckResult.lower(value)
}


/**
 * Encrypted key backup for export/import.
 */
public struct KeyBackup {
    /**
     * Version of the backup format.
     */
    public var version: UInt32
    /**
     * Encrypted secret key (AES-GCM).
     */
    public var encryptedDataHex: String
    /**
     * Salt for key derivation from password.
     */
    public var saltHex: String
    /**
     * Nonce for AES-GCM.
     */
    public var nonceHex: String
    /**
     * Public key (not encrypted, for identification).
     */
    public var publicKeyZ32: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Version of the backup format.
         */version: UInt32, 
        /**
         * Encrypted secret key (AES-GCM).
         */encryptedDataHex: String, 
        /**
         * Salt for key derivation from password.
         */saltHex: String, 
        /**
         * Nonce for AES-GCM.
         */nonceHex: String, 
        /**
         * Public key (not encrypted, for identification).
         */publicKeyZ32: String) {
        self.version = version
        self.encryptedDataHex = encryptedDataHex
        self.saltHex = saltHex
        self.nonceHex = nonceHex
        self.publicKeyZ32 = publicKeyZ32
    }
}

#if compiler(>=6)
extension KeyBackup: Sendable {}
#endif


extension KeyBackup: Equatable, Hashable {
    public static func ==(lhs: KeyBackup, rhs: KeyBackup) -> Bool {
        if lhs.version != rhs.version {
            return false
        }
        if lhs.encryptedDataHex != rhs.encryptedDataHex {
            return false
        }
        if lhs.saltHex != rhs.saltHex {
            return false
        }
        if lhs.nonceHex != rhs.nonceHex {
            return false
        }
        if lhs.publicKeyZ32 != rhs.publicKeyZ32 {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(version)
        hasher.combine(encryptedDataHex)
        hasher.combine(saltHex)
        hasher.combine(nonceHex)
        hasher.combine(publicKeyZ32)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeKeyBackup: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeyBackup {
        return
            try KeyBackup(
                version: FfiConverterUInt32.read(from: &buf), 
                encryptedDataHex: FfiConverterString.read(from: &buf), 
                saltHex: FfiConverterString.read(from: &buf), 
                nonceHex: FfiConverterString.read(from: &buf), 
                publicKeyZ32: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: KeyBackup, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.version, into: &buf)
        FfiConverterString.write(value.encryptedDataHex, into: &buf)
        FfiConverterString.write(value.saltHex, into: &buf)
        FfiConverterString.write(value.nonceHex, into: &buf)
        FfiConverterString.write(value.publicKeyZ32, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeyBackup_lift(_ buf: RustBuffer) throws -> KeyBackup {
    return try FfiConverterTypeKeyBackup.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeyBackup_lower(_ value: KeyBackup) -> RustBuffer {
    return FfiConverterTypeKeyBackup.lower(value)
}


/**
 * Result of a Lightning payment (FFI-compatible).
 *
 * This type is returned by `LightningExecutorFFI::payInvoice()` after
 * a successful Lightning payment.
 */
public struct LightningPaymentResultFfi {
    /**
     * The payment preimage (hex-encoded, 64 characters).
     * This is the cryptographic proof of payment.
     */
    public var preimage: String
    /**
     * The payment hash (hex-encoded, 64 characters).
     */
    public var paymentHash: String
    /**
     * The amount paid in millisatoshis.
     */
    public var amountMsat: UInt64
    /**
     * The fee paid in millisatoshis.
     */
    public var feeMsat: UInt64
    /**
     * Number of hops in the payment route.
     */
    public var hops: UInt32
    /**
     * Payment status.
     */
    public var status: LightningPaymentStatusFfi

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The payment preimage (hex-encoded, 64 characters).
         * This is the cryptographic proof of payment.
         */preimage: String, 
        /**
         * The payment hash (hex-encoded, 64 characters).
         */paymentHash: String, 
        /**
         * The amount paid in millisatoshis.
         */amountMsat: UInt64, 
        /**
         * The fee paid in millisatoshis.
         */feeMsat: UInt64, 
        /**
         * Number of hops in the payment route.
         */hops: UInt32, 
        /**
         * Payment status.
         */status: LightningPaymentStatusFfi) {
        self.preimage = preimage
        self.paymentHash = paymentHash
        self.amountMsat = amountMsat
        self.feeMsat = feeMsat
        self.hops = hops
        self.status = status
    }
}

#if compiler(>=6)
extension LightningPaymentResultFfi: Sendable {}
#endif


extension LightningPaymentResultFfi: Equatable, Hashable {
    public static func ==(lhs: LightningPaymentResultFfi, rhs: LightningPaymentResultFfi) -> Bool {
        if lhs.preimage != rhs.preimage {
            return false
        }
        if lhs.paymentHash != rhs.paymentHash {
            return false
        }
        if lhs.amountMsat != rhs.amountMsat {
            return false
        }
        if lhs.feeMsat != rhs.feeMsat {
            return false
        }
        if lhs.hops != rhs.hops {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(preimage)
        hasher.combine(paymentHash)
        hasher.combine(amountMsat)
        hasher.combine(feeMsat)
        hasher.combine(hops)
        hasher.combine(status)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLightningPaymentResultFFI: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LightningPaymentResultFfi {
        return
            try LightningPaymentResultFfi(
                preimage: FfiConverterString.read(from: &buf), 
                paymentHash: FfiConverterString.read(from: &buf), 
                amountMsat: FfiConverterUInt64.read(from: &buf), 
                feeMsat: FfiConverterUInt64.read(from: &buf), 
                hops: FfiConverterUInt32.read(from: &buf), 
                status: FfiConverterTypeLightningPaymentStatusFFI.read(from: &buf)
        )
    }

    public static func write(_ value: LightningPaymentResultFfi, into buf: inout [UInt8]) {
        FfiConverterString.write(value.preimage, into: &buf)
        FfiConverterString.write(value.paymentHash, into: &buf)
        FfiConverterUInt64.write(value.amountMsat, into: &buf)
        FfiConverterUInt64.write(value.feeMsat, into: &buf)
        FfiConverterUInt32.write(value.hops, into: &buf)
        FfiConverterTypeLightningPaymentStatusFFI.write(value.status, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLightningPaymentResultFFI_lift(_ buf: RustBuffer) throws -> LightningPaymentResultFfi {
    return try FfiConverterTypeLightningPaymentResultFFI.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLightningPaymentResultFFI_lower(_ value: LightningPaymentResultFfi) -> RustBuffer {
    return FfiConverterTypeLightningPaymentResultFFI.lower(value)
}


/**
 * A payment method identifier.
 */
public struct MethodId {
    public var value: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: String) {
        self.value = value
    }
}

#if compiler(>=6)
extension MethodId: Sendable {}
#endif


extension MethodId: Equatable, Hashable {
    public static func ==(lhs: MethodId, rhs: MethodId) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMethodId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MethodId {
        return
            try MethodId(
                value: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: MethodId, into buf: inout [UInt8]) {
        FfiConverterString.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMethodId_lift(_ buf: RustBuffer) throws -> MethodId {
    return try FfiConverterTypeMethodId.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMethodId_lower(_ value: MethodId) -> RustBuffer {
    return FfiConverterTypeMethodId.lower(value)
}


/**
 * Information about a Noise protocol endpoint for receiving payments.
 *
 * This is discovered from a recipient's public directory and contains
 * the connection information needed to establish a Noise session.
 */
public struct NoiseEndpointInfo {
    /**
     * The recipient's public key (z-base32 encoded).
     */
    public var recipientPubkey: String
    /**
     * Host address of the Noise server (IP or hostname).
     */
    public var host: String
    /**
     * Port number of the Noise server.
     */
    public var port: UInt16
    /**
     * The server's Noise public key (X25519, hex encoded).
     * This is needed to verify the server during handshake.
     */
    public var serverNoisePubkey: String
    /**
     * Optional metadata about the endpoint.
     */
    public var metadata: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The recipient's public key (z-base32 encoded).
         */recipientPubkey: String, 
        /**
         * Host address of the Noise server (IP or hostname).
         */host: String, 
        /**
         * Port number of the Noise server.
         */port: UInt16, 
        /**
         * The server's Noise public key (X25519, hex encoded).
         * This is needed to verify the server during handshake.
         */serverNoisePubkey: String, 
        /**
         * Optional metadata about the endpoint.
         */metadata: String?) {
        self.recipientPubkey = recipientPubkey
        self.host = host
        self.port = port
        self.serverNoisePubkey = serverNoisePubkey
        self.metadata = metadata
    }
}

#if compiler(>=6)
extension NoiseEndpointInfo: Sendable {}
#endif


extension NoiseEndpointInfo: Equatable, Hashable {
    public static func ==(lhs: NoiseEndpointInfo, rhs: NoiseEndpointInfo) -> Bool {
        if lhs.recipientPubkey != rhs.recipientPubkey {
            return false
        }
        if lhs.host != rhs.host {
            return false
        }
        if lhs.port != rhs.port {
            return false
        }
        if lhs.serverNoisePubkey != rhs.serverNoisePubkey {
            return false
        }
        if lhs.metadata != rhs.metadata {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(recipientPubkey)
        hasher.combine(host)
        hasher.combine(port)
        hasher.combine(serverNoisePubkey)
        hasher.combine(metadata)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNoiseEndpointInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NoiseEndpointInfo {
        return
            try NoiseEndpointInfo(
                recipientPubkey: FfiConverterString.read(from: &buf), 
                host: FfiConverterString.read(from: &buf), 
                port: FfiConverterUInt16.read(from: &buf), 
                serverNoisePubkey: FfiConverterString.read(from: &buf), 
                metadata: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: NoiseEndpointInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.recipientPubkey, into: &buf)
        FfiConverterString.write(value.host, into: &buf)
        FfiConverterUInt16.write(value.port, into: &buf)
        FfiConverterString.write(value.serverNoisePubkey, into: &buf)
        FfiConverterOptionString.write(value.metadata, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNoiseEndpointInfo_lift(_ buf: RustBuffer) throws -> NoiseEndpointInfo {
    return try FfiConverterTypeNoiseEndpointInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNoiseEndpointInfo_lower(_ value: NoiseEndpointInfo) -> RustBuffer {
    return FfiConverterTypeNoiseEndpointInfo.lower(value)
}


/**
 * Result of a Noise handshake operation.
 */
public struct NoiseHandshakeResult {
    /**
     * Whether the handshake succeeded.
     */
    public var success: Bool
    /**
     * Session ID for this connection (if successful).
     */
    public var sessionId: String?
    /**
     * Remote peer's public key (z-base32 encoded, if successful).
     */
    public var remotePubkey: String?
    /**
     * Error message (if failed).
     */
    public var error: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Whether the handshake succeeded.
         */success: Bool, 
        /**
         * Session ID for this connection (if successful).
         */sessionId: String?, 
        /**
         * Remote peer's public key (z-base32 encoded, if successful).
         */remotePubkey: String?, 
        /**
         * Error message (if failed).
         */error: String?) {
        self.success = success
        self.sessionId = sessionId
        self.remotePubkey = remotePubkey
        self.error = error
    }
}

#if compiler(>=6)
extension NoiseHandshakeResult: Sendable {}
#endif


extension NoiseHandshakeResult: Equatable, Hashable {
    public static func ==(lhs: NoiseHandshakeResult, rhs: NoiseHandshakeResult) -> Bool {
        if lhs.success != rhs.success {
            return false
        }
        if lhs.sessionId != rhs.sessionId {
            return false
        }
        if lhs.remotePubkey != rhs.remotePubkey {
            return false
        }
        if lhs.error != rhs.error {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(success)
        hasher.combine(sessionId)
        hasher.combine(remotePubkey)
        hasher.combine(error)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNoiseHandshakeResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NoiseHandshakeResult {
        return
            try NoiseHandshakeResult(
                success: FfiConverterBool.read(from: &buf), 
                sessionId: FfiConverterOptionString.read(from: &buf), 
                remotePubkey: FfiConverterOptionString.read(from: &buf), 
                error: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: NoiseHandshakeResult, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.success, into: &buf)
        FfiConverterOptionString.write(value.sessionId, into: &buf)
        FfiConverterOptionString.write(value.remotePubkey, into: &buf)
        FfiConverterOptionString.write(value.error, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNoiseHandshakeResult_lift(_ buf: RustBuffer) throws -> NoiseHandshakeResult {
    return try FfiConverterTypeNoiseHandshakeResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNoiseHandshakeResult_lower(_ value: NoiseHandshakeResult) -> RustBuffer {
    return FfiConverterTypeNoiseHandshakeResult.lower(value)
}


/**
 * A payment message to send over Noise channel.
 */
public struct NoisePaymentMessage {
    /**
     * Type of the message.
     */
    public var messageType: NoisePaymentMessageType
    /**
     * JSON payload of the message.
     */
    public var payloadJson: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Type of the message.
         */messageType: NoisePaymentMessageType, 
        /**
         * JSON payload of the message.
         */payloadJson: String) {
        self.messageType = messageType
        self.payloadJson = payloadJson
    }
}

#if compiler(>=6)
extension NoisePaymentMessage: Sendable {}
#endif


extension NoisePaymentMessage: Equatable, Hashable {
    public static func ==(lhs: NoisePaymentMessage, rhs: NoisePaymentMessage) -> Bool {
        if lhs.messageType != rhs.messageType {
            return false
        }
        if lhs.payloadJson != rhs.payloadJson {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(messageType)
        hasher.combine(payloadJson)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNoisePaymentMessage: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NoisePaymentMessage {
        return
            try NoisePaymentMessage(
                messageType: FfiConverterTypeNoisePaymentMessageType.read(from: &buf), 
                payloadJson: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: NoisePaymentMessage, into buf: inout [UInt8]) {
        FfiConverterTypeNoisePaymentMessageType.write(value.messageType, into: &buf)
        FfiConverterString.write(value.payloadJson, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNoisePaymentMessage_lift(_ buf: RustBuffer) throws -> NoisePaymentMessage {
    return try FfiConverterTypeNoisePaymentMessage.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNoisePaymentMessage_lower(_ value: NoisePaymentMessage) -> RustBuffer {
    return FfiConverterTypeNoisePaymentMessage.lower(value)
}


/**
 * Configuration for a Noise server (receiving payments).
 */
public struct NoiseServerConfig {
    /**
     * The port to listen on (0 for auto-assign).
     */
    public var port: UInt16
    /**
     * Maximum number of concurrent connections.
     */
    public var maxConnections: UInt32
    /**
     * Connection timeout in seconds.
     */
    public var connectionTimeoutSecs: UInt32
    /**
     * Whether to automatically publish endpoint to directory.
     */
    public var autoPublish: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The port to listen on (0 for auto-assign).
         */port: UInt16, 
        /**
         * Maximum number of concurrent connections.
         */maxConnections: UInt32, 
        /**
         * Connection timeout in seconds.
         */connectionTimeoutSecs: UInt32, 
        /**
         * Whether to automatically publish endpoint to directory.
         */autoPublish: Bool) {
        self.port = port
        self.maxConnections = maxConnections
        self.connectionTimeoutSecs = connectionTimeoutSecs
        self.autoPublish = autoPublish
    }
}

#if compiler(>=6)
extension NoiseServerConfig: Sendable {}
#endif


extension NoiseServerConfig: Equatable, Hashable {
    public static func ==(lhs: NoiseServerConfig, rhs: NoiseServerConfig) -> Bool {
        if lhs.port != rhs.port {
            return false
        }
        if lhs.maxConnections != rhs.maxConnections {
            return false
        }
        if lhs.connectionTimeoutSecs != rhs.connectionTimeoutSecs {
            return false
        }
        if lhs.autoPublish != rhs.autoPublish {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(port)
        hasher.combine(maxConnections)
        hasher.combine(connectionTimeoutSecs)
        hasher.combine(autoPublish)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNoiseServerConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NoiseServerConfig {
        return
            try NoiseServerConfig(
                port: FfiConverterUInt16.read(from: &buf), 
                maxConnections: FfiConverterUInt32.read(from: &buf), 
                connectionTimeoutSecs: FfiConverterUInt32.read(from: &buf), 
                autoPublish: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: NoiseServerConfig, into buf: inout [UInt8]) {
        FfiConverterUInt16.write(value.port, into: &buf)
        FfiConverterUInt32.write(value.maxConnections, into: &buf)
        FfiConverterUInt32.write(value.connectionTimeoutSecs, into: &buf)
        FfiConverterBool.write(value.autoPublish, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNoiseServerConfig_lift(_ buf: RustBuffer) throws -> NoiseServerConfig {
    return try FfiConverterTypeNoiseServerConfig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNoiseServerConfig_lower(_ value: NoiseServerConfig) -> RustBuffer {
    return FfiConverterTypeNoiseServerConfig.lower(value)
}


/**
 * Status of the Noise server.
 */
public struct NoiseServerStatus {
    /**
     * Whether the server is currently running.
     */
    public var isRunning: Bool
    /**
     * The port the server is listening on (if running).
     */
    public var port: UInt16?
    /**
     * The server's Noise public key (X25519, hex encoded).
     */
    public var noisePubkey: String
    /**
     * Number of active sessions.
     */
    public var activeSessions: UInt32
    /**
     * Total connections handled since start.
     */
    public var totalConnections: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Whether the server is currently running.
         */isRunning: Bool, 
        /**
         * The port the server is listening on (if running).
         */port: UInt16?, 
        /**
         * The server's Noise public key (X25519, hex encoded).
         */noisePubkey: String, 
        /**
         * Number of active sessions.
         */activeSessions: UInt32, 
        /**
         * Total connections handled since start.
         */totalConnections: UInt64) {
        self.isRunning = isRunning
        self.port = port
        self.noisePubkey = noisePubkey
        self.activeSessions = activeSessions
        self.totalConnections = totalConnections
    }
}

#if compiler(>=6)
extension NoiseServerStatus: Sendable {}
#endif


extension NoiseServerStatus: Equatable, Hashable {
    public static func ==(lhs: NoiseServerStatus, rhs: NoiseServerStatus) -> Bool {
        if lhs.isRunning != rhs.isRunning {
            return false
        }
        if lhs.port != rhs.port {
            return false
        }
        if lhs.noisePubkey != rhs.noisePubkey {
            return false
        }
        if lhs.activeSessions != rhs.activeSessions {
            return false
        }
        if lhs.totalConnections != rhs.totalConnections {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(isRunning)
        hasher.combine(port)
        hasher.combine(noisePubkey)
        hasher.combine(activeSessions)
        hasher.combine(totalConnections)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNoiseServerStatus: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NoiseServerStatus {
        return
            try NoiseServerStatus(
                isRunning: FfiConverterBool.read(from: &buf), 
                port: FfiConverterOptionUInt16.read(from: &buf), 
                noisePubkey: FfiConverterString.read(from: &buf), 
                activeSessions: FfiConverterUInt32.read(from: &buf), 
                totalConnections: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: NoiseServerStatus, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.isRunning, into: &buf)
        FfiConverterOptionUInt16.write(value.port, into: &buf)
        FfiConverterString.write(value.noisePubkey, into: &buf)
        FfiConverterUInt32.write(value.activeSessions, into: &buf)
        FfiConverterUInt64.write(value.totalConnections, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNoiseServerStatus_lift(_ buf: RustBuffer) throws -> NoiseServerStatus {
    return try FfiConverterTypeNoiseServerStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNoiseServerStatus_lower(_ value: NoiseServerStatus) -> RustBuffer {
    return FfiConverterTypeNoiseServerStatus.lower(value)
}


/**
 * Information about an active Noise session.
 */
public struct NoiseSessionInfo {
    /**
     * Unique session identifier.
     */
    public var sessionId: String
    /**
     * Remote peer's public key (z-base32 encoded).
     */
    public var remotePubkey: String
    /**
     * When the session was established (unix timestamp).
     */
    public var establishedAt: Int64
    /**
     * Whether this is an incoming (server) or outgoing (client) session.
     */
    public var isIncoming: Bool
    /**
     * Number of messages sent in this session.
     */
    public var messagesSent: UInt64
    /**
     * Number of messages received in this session.
     */
    public var messagesReceived: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique session identifier.
         */sessionId: String, 
        /**
         * Remote peer's public key (z-base32 encoded).
         */remotePubkey: String, 
        /**
         * When the session was established (unix timestamp).
         */establishedAt: Int64, 
        /**
         * Whether this is an incoming (server) or outgoing (client) session.
         */isIncoming: Bool, 
        /**
         * Number of messages sent in this session.
         */messagesSent: UInt64, 
        /**
         * Number of messages received in this session.
         */messagesReceived: UInt64) {
        self.sessionId = sessionId
        self.remotePubkey = remotePubkey
        self.establishedAt = establishedAt
        self.isIncoming = isIncoming
        self.messagesSent = messagesSent
        self.messagesReceived = messagesReceived
    }
}

#if compiler(>=6)
extension NoiseSessionInfo: Sendable {}
#endif


extension NoiseSessionInfo: Equatable, Hashable {
    public static func ==(lhs: NoiseSessionInfo, rhs: NoiseSessionInfo) -> Bool {
        if lhs.sessionId != rhs.sessionId {
            return false
        }
        if lhs.remotePubkey != rhs.remotePubkey {
            return false
        }
        if lhs.establishedAt != rhs.establishedAt {
            return false
        }
        if lhs.isIncoming != rhs.isIncoming {
            return false
        }
        if lhs.messagesSent != rhs.messagesSent {
            return false
        }
        if lhs.messagesReceived != rhs.messagesReceived {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sessionId)
        hasher.combine(remotePubkey)
        hasher.combine(establishedAt)
        hasher.combine(isIncoming)
        hasher.combine(messagesSent)
        hasher.combine(messagesReceived)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNoiseSessionInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NoiseSessionInfo {
        return
            try NoiseSessionInfo(
                sessionId: FfiConverterString.read(from: &buf), 
                remotePubkey: FfiConverterString.read(from: &buf), 
                establishedAt: FfiConverterInt64.read(from: &buf), 
                isIncoming: FfiConverterBool.read(from: &buf), 
                messagesSent: FfiConverterUInt64.read(from: &buf), 
                messagesReceived: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: NoiseSessionInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.sessionId, into: &buf)
        FfiConverterString.write(value.remotePubkey, into: &buf)
        FfiConverterInt64.write(value.establishedAt, into: &buf)
        FfiConverterBool.write(value.isIncoming, into: &buf)
        FfiConverterUInt64.write(value.messagesSent, into: &buf)
        FfiConverterUInt64.write(value.messagesReceived, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNoiseSessionInfo_lift(_ buf: RustBuffer) throws -> NoiseSessionInfo {
    return try FfiConverterTypeNoiseSessionInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNoiseSessionInfo_lower(_ value: NoiseSessionInfo) -> RustBuffer {
    return FfiConverterTypeNoiseSessionInfo.lower(value)
}


/**
 * Result of a payment execution.
 *
 * Returned by `PaykitClient::execute_payment()` after attempting to
 * send a payment via the registered wallet executor.
 */
public struct PaymentExecutionResult {
    /**
     * Unique execution ID.
     */
    public var executionId: String
    /**
     * Payment method used.
     */
    public var methodId: String
    /**
     * Payment destination.
     */
    public var endpoint: String
    /**
     * Amount sent in satoshis.
     */
    public var amountSats: UInt64
    /**
     * Whether the payment succeeded.
     */
    public var success: Bool
    /**
     * Unix timestamp of execution.
     */
    public var executedAt: Int64
    /**
     * Execution details as JSON (contains txid, preimage, fees, etc.).
     */
    public var executionDataJson: String
    /**
     * Error message if failed.
     */
    public var error: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique execution ID.
         */executionId: String, 
        /**
         * Payment method used.
         */methodId: String, 
        /**
         * Payment destination.
         */endpoint: String, 
        /**
         * Amount sent in satoshis.
         */amountSats: UInt64, 
        /**
         * Whether the payment succeeded.
         */success: Bool, 
        /**
         * Unix timestamp of execution.
         */executedAt: Int64, 
        /**
         * Execution details as JSON (contains txid, preimage, fees, etc.).
         */executionDataJson: String, 
        /**
         * Error message if failed.
         */error: String?) {
        self.executionId = executionId
        self.methodId = methodId
        self.endpoint = endpoint
        self.amountSats = amountSats
        self.success = success
        self.executedAt = executedAt
        self.executionDataJson = executionDataJson
        self.error = error
    }
}

#if compiler(>=6)
extension PaymentExecutionResult: Sendable {}
#endif


extension PaymentExecutionResult: Equatable, Hashable {
    public static func ==(lhs: PaymentExecutionResult, rhs: PaymentExecutionResult) -> Bool {
        if lhs.executionId != rhs.executionId {
            return false
        }
        if lhs.methodId != rhs.methodId {
            return false
        }
        if lhs.endpoint != rhs.endpoint {
            return false
        }
        if lhs.amountSats != rhs.amountSats {
            return false
        }
        if lhs.success != rhs.success {
            return false
        }
        if lhs.executedAt != rhs.executedAt {
            return false
        }
        if lhs.executionDataJson != rhs.executionDataJson {
            return false
        }
        if lhs.error != rhs.error {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(executionId)
        hasher.combine(methodId)
        hasher.combine(endpoint)
        hasher.combine(amountSats)
        hasher.combine(success)
        hasher.combine(executedAt)
        hasher.combine(executionDataJson)
        hasher.combine(error)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentExecutionResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentExecutionResult {
        return
            try PaymentExecutionResult(
                executionId: FfiConverterString.read(from: &buf), 
                methodId: FfiConverterString.read(from: &buf), 
                endpoint: FfiConverterString.read(from: &buf), 
                amountSats: FfiConverterUInt64.read(from: &buf), 
                success: FfiConverterBool.read(from: &buf), 
                executedAt: FfiConverterInt64.read(from: &buf), 
                executionDataJson: FfiConverterString.read(from: &buf), 
                error: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: PaymentExecutionResult, into buf: inout [UInt8]) {
        FfiConverterString.write(value.executionId, into: &buf)
        FfiConverterString.write(value.methodId, into: &buf)
        FfiConverterString.write(value.endpoint, into: &buf)
        FfiConverterUInt64.write(value.amountSats, into: &buf)
        FfiConverterBool.write(value.success, into: &buf)
        FfiConverterInt64.write(value.executedAt, into: &buf)
        FfiConverterString.write(value.executionDataJson, into: &buf)
        FfiConverterOptionString.write(value.error, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentExecutionResult_lift(_ buf: RustBuffer) throws -> PaymentExecutionResult {
    return try FfiConverterTypePaymentExecutionResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentExecutionResult_lower(_ value: PaymentExecutionResult) -> RustBuffer {
    return FfiConverterTypePaymentExecutionResult.lower(value)
}


/**
 * A supported payment method with its endpoint.
 */
public struct PaymentMethod {
    public var methodId: String
    public var endpoint: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(methodId: String, endpoint: String) {
        self.methodId = methodId
        self.endpoint = endpoint
    }
}

#if compiler(>=6)
extension PaymentMethod: Sendable {}
#endif


extension PaymentMethod: Equatable, Hashable {
    public static func ==(lhs: PaymentMethod, rhs: PaymentMethod) -> Bool {
        if lhs.methodId != rhs.methodId {
            return false
        }
        if lhs.endpoint != rhs.endpoint {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(methodId)
        hasher.combine(endpoint)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentMethod: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentMethod {
        return
            try PaymentMethod(
                methodId: FfiConverterString.read(from: &buf), 
                endpoint: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PaymentMethod, into buf: inout [UInt8]) {
        FfiConverterString.write(value.methodId, into: &buf)
        FfiConverterString.write(value.endpoint, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentMethod_lift(_ buf: RustBuffer) throws -> PaymentMethod {
    return try FfiConverterTypePaymentMethod.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentMethod_lower(_ value: PaymentMethod) -> RustBuffer {
    return FfiConverterTypePaymentMethod.lower(value)
}


/**
 * Result of generating a payment proof.
 *
 * Returned by `PaykitClient::generate_payment_proof()` after
 * extracting proof data from a successful payment execution.
 */
public struct PaymentProofResult {
    /**
     * Type of proof ("bitcoin_txid", "lightning_preimage", "custom").
     */
    public var proofType: String
    /**
     * Proof data as JSON.
     */
    public var proofDataJson: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Type of proof ("bitcoin_txid", "lightning_preimage", "custom").
         */proofType: String, 
        /**
         * Proof data as JSON.
         */proofDataJson: String) {
        self.proofType = proofType
        self.proofDataJson = proofDataJson
    }
}

#if compiler(>=6)
extension PaymentProofResult: Sendable {}
#endif


extension PaymentProofResult: Equatable, Hashable {
    public static func ==(lhs: PaymentProofResult, rhs: PaymentProofResult) -> Bool {
        if lhs.proofType != rhs.proofType {
            return false
        }
        if lhs.proofDataJson != rhs.proofDataJson {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(proofType)
        hasher.combine(proofDataJson)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentProofResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentProofResult {
        return
            try PaymentProofResult(
                proofType: FfiConverterString.read(from: &buf), 
                proofDataJson: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PaymentProofResult, into buf: inout [UInt8]) {
        FfiConverterString.write(value.proofType, into: &buf)
        FfiConverterString.write(value.proofDataJson, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentProofResult_lift(_ buf: RustBuffer) throws -> PaymentProofResult {
    return try FfiConverterTypePaymentProofResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentProofResult_lower(_ value: PaymentProofResult) -> RustBuffer {
    return FfiConverterTypePaymentProofResult.lower(value)
}


/**
 * Payment request.
 */
public struct PaymentRequest {
    public var requestId: String
    public var fromPubkey: String
    public var toPubkey: String
    public var amountSats: Int64
    public var currency: String
    public var methodId: String
    public var description: String
    public var createdAt: Int64
    public var expiresAt: Int64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(requestId: String, fromPubkey: String, toPubkey: String, amountSats: Int64, currency: String, methodId: String, description: String, createdAt: Int64, expiresAt: Int64?) {
        self.requestId = requestId
        self.fromPubkey = fromPubkey
        self.toPubkey = toPubkey
        self.amountSats = amountSats
        self.currency = currency
        self.methodId = methodId
        self.description = description
        self.createdAt = createdAt
        self.expiresAt = expiresAt
    }
}

#if compiler(>=6)
extension PaymentRequest: Sendable {}
#endif


extension PaymentRequest: Equatable, Hashable {
    public static func ==(lhs: PaymentRequest, rhs: PaymentRequest) -> Bool {
        if lhs.requestId != rhs.requestId {
            return false
        }
        if lhs.fromPubkey != rhs.fromPubkey {
            return false
        }
        if lhs.toPubkey != rhs.toPubkey {
            return false
        }
        if lhs.amountSats != rhs.amountSats {
            return false
        }
        if lhs.currency != rhs.currency {
            return false
        }
        if lhs.methodId != rhs.methodId {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.expiresAt != rhs.expiresAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(requestId)
        hasher.combine(fromPubkey)
        hasher.combine(toPubkey)
        hasher.combine(amountSats)
        hasher.combine(currency)
        hasher.combine(methodId)
        hasher.combine(description)
        hasher.combine(createdAt)
        hasher.combine(expiresAt)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentRequest {
        return
            try PaymentRequest(
                requestId: FfiConverterString.read(from: &buf), 
                fromPubkey: FfiConverterString.read(from: &buf), 
                toPubkey: FfiConverterString.read(from: &buf), 
                amountSats: FfiConverterInt64.read(from: &buf), 
                currency: FfiConverterString.read(from: &buf), 
                methodId: FfiConverterString.read(from: &buf), 
                description: FfiConverterString.read(from: &buf), 
                createdAt: FfiConverterInt64.read(from: &buf), 
                expiresAt: FfiConverterOptionInt64.read(from: &buf)
        )
    }

    public static func write(_ value: PaymentRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.requestId, into: &buf)
        FfiConverterString.write(value.fromPubkey, into: &buf)
        FfiConverterString.write(value.toPubkey, into: &buf)
        FfiConverterInt64.write(value.amountSats, into: &buf)
        FfiConverterString.write(value.currency, into: &buf)
        FfiConverterString.write(value.methodId, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterInt64.write(value.createdAt, into: &buf)
        FfiConverterOptionInt64.write(value.expiresAt, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentRequest_lift(_ buf: RustBuffer) throws -> PaymentRequest {
    return try FfiConverterTypePaymentRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentRequest_lower(_ value: PaymentRequest) -> RustBuffer {
    return FfiConverterTypePaymentRequest.lower(value)
}


/**
 * Payment status information.
 */
public struct PaymentStatusInfo {
    public var status: PaymentStatus
    public var receiptId: String
    public var methodId: String
    public var updatedAt: Int64
    public var confirmations: UInt64?
    public var requiredConfirmations: UInt64?
    public var error: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(status: PaymentStatus, receiptId: String, methodId: String, updatedAt: Int64, confirmations: UInt64?, requiredConfirmations: UInt64?, error: String?) {
        self.status = status
        self.receiptId = receiptId
        self.methodId = methodId
        self.updatedAt = updatedAt
        self.confirmations = confirmations
        self.requiredConfirmations = requiredConfirmations
        self.error = error
    }
}

#if compiler(>=6)
extension PaymentStatusInfo: Sendable {}
#endif


extension PaymentStatusInfo: Equatable, Hashable {
    public static func ==(lhs: PaymentStatusInfo, rhs: PaymentStatusInfo) -> Bool {
        if lhs.status != rhs.status {
            return false
        }
        if lhs.receiptId != rhs.receiptId {
            return false
        }
        if lhs.methodId != rhs.methodId {
            return false
        }
        if lhs.updatedAt != rhs.updatedAt {
            return false
        }
        if lhs.confirmations != rhs.confirmations {
            return false
        }
        if lhs.requiredConfirmations != rhs.requiredConfirmations {
            return false
        }
        if lhs.error != rhs.error {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(status)
        hasher.combine(receiptId)
        hasher.combine(methodId)
        hasher.combine(updatedAt)
        hasher.combine(confirmations)
        hasher.combine(requiredConfirmations)
        hasher.combine(error)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentStatusInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentStatusInfo {
        return
            try PaymentStatusInfo(
                status: FfiConverterTypePaymentStatus.read(from: &buf), 
                receiptId: FfiConverterString.read(from: &buf), 
                methodId: FfiConverterString.read(from: &buf), 
                updatedAt: FfiConverterInt64.read(from: &buf), 
                confirmations: FfiConverterOptionUInt64.read(from: &buf), 
                requiredConfirmations: FfiConverterOptionUInt64.read(from: &buf), 
                error: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: PaymentStatusInfo, into buf: inout [UInt8]) {
        FfiConverterTypePaymentStatus.write(value.status, into: &buf)
        FfiConverterString.write(value.receiptId, into: &buf)
        FfiConverterString.write(value.methodId, into: &buf)
        FfiConverterInt64.write(value.updatedAt, into: &buf)
        FfiConverterOptionUInt64.write(value.confirmations, into: &buf)
        FfiConverterOptionUInt64.write(value.requiredConfirmations, into: &buf)
        FfiConverterOptionString.write(value.error, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentStatusInfo_lift(_ buf: RustBuffer) throws -> PaymentStatusInfo {
    return try FfiConverterTypePaymentStatusInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentStatusInfo_lower(_ value: PaymentStatusInfo) -> RustBuffer {
    return FfiConverterTypePaymentStatusInfo.lower(value)
}


/**
 * FFI-safe peer spending limit information.
 */
public struct PeerSpendingLimitFfi {
    /**
     * Peer public key (z-base32 encoded)
     */
    public var peerPubkey: String
    /**
     * Total spending limit in satoshis
     */
    public var totalLimitSats: Int64
    /**
     * Currently spent amount in satoshis
     */
    public var currentSpentSats: Int64
    /**
     * Period for limit reset ("daily", "weekly", "monthly")
     */
    public var period: String
    /**
     * Remaining limit in satoshis
     */
    public var remainingSats: Int64
    /**
     * Unix timestamp of last reset
     */
    public var lastReset: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Peer public key (z-base32 encoded)
         */peerPubkey: String, 
        /**
         * Total spending limit in satoshis
         */totalLimitSats: Int64, 
        /**
         * Currently spent amount in satoshis
         */currentSpentSats: Int64, 
        /**
         * Period for limit reset ("daily", "weekly", "monthly")
         */period: String, 
        /**
         * Remaining limit in satoshis
         */remainingSats: Int64, 
        /**
         * Unix timestamp of last reset
         */lastReset: Int64) {
        self.peerPubkey = peerPubkey
        self.totalLimitSats = totalLimitSats
        self.currentSpentSats = currentSpentSats
        self.period = period
        self.remainingSats = remainingSats
        self.lastReset = lastReset
    }
}

#if compiler(>=6)
extension PeerSpendingLimitFfi: Sendable {}
#endif


extension PeerSpendingLimitFfi: Equatable, Hashable {
    public static func ==(lhs: PeerSpendingLimitFfi, rhs: PeerSpendingLimitFfi) -> Bool {
        if lhs.peerPubkey != rhs.peerPubkey {
            return false
        }
        if lhs.totalLimitSats != rhs.totalLimitSats {
            return false
        }
        if lhs.currentSpentSats != rhs.currentSpentSats {
            return false
        }
        if lhs.period != rhs.period {
            return false
        }
        if lhs.remainingSats != rhs.remainingSats {
            return false
        }
        if lhs.lastReset != rhs.lastReset {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(peerPubkey)
        hasher.combine(totalLimitSats)
        hasher.combine(currentSpentSats)
        hasher.combine(period)
        hasher.combine(remainingSats)
        hasher.combine(lastReset)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePeerSpendingLimitFFI: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PeerSpendingLimitFfi {
        return
            try PeerSpendingLimitFfi(
                peerPubkey: FfiConverterString.read(from: &buf), 
                totalLimitSats: FfiConverterInt64.read(from: &buf), 
                currentSpentSats: FfiConverterInt64.read(from: &buf), 
                period: FfiConverterString.read(from: &buf), 
                remainingSats: FfiConverterInt64.read(from: &buf), 
                lastReset: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: PeerSpendingLimitFfi, into buf: inout [UInt8]) {
        FfiConverterString.write(value.peerPubkey, into: &buf)
        FfiConverterInt64.write(value.totalLimitSats, into: &buf)
        FfiConverterInt64.write(value.currentSpentSats, into: &buf)
        FfiConverterString.write(value.period, into: &buf)
        FfiConverterInt64.write(value.remainingSats, into: &buf)
        FfiConverterInt64.write(value.lastReset, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePeerSpendingLimitFFI_lift(_ buf: RustBuffer) throws -> PeerSpendingLimitFfi {
    return try FfiConverterTypePeerSpendingLimitFFI.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePeerSpendingLimitFFI_lower(_ value: PeerSpendingLimitFfi) -> RustBuffer {
    return FfiConverterTypePeerSpendingLimitFFI.lower(value)
}


/**
 * Private endpoint information.
 */
public struct PrivateEndpoint {
    public var peer: String
    public var methodId: String
    public var endpoint: String
    public var createdAt: Int64
    public var expiresAt: Int64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(peer: String, methodId: String, endpoint: String, createdAt: Int64, expiresAt: Int64?) {
        self.peer = peer
        self.methodId = methodId
        self.endpoint = endpoint
        self.createdAt = createdAt
        self.expiresAt = expiresAt
    }
}

#if compiler(>=6)
extension PrivateEndpoint: Sendable {}
#endif


extension PrivateEndpoint: Equatable, Hashable {
    public static func ==(lhs: PrivateEndpoint, rhs: PrivateEndpoint) -> Bool {
        if lhs.peer != rhs.peer {
            return false
        }
        if lhs.methodId != rhs.methodId {
            return false
        }
        if lhs.endpoint != rhs.endpoint {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.expiresAt != rhs.expiresAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(peer)
        hasher.combine(methodId)
        hasher.combine(endpoint)
        hasher.combine(createdAt)
        hasher.combine(expiresAt)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePrivateEndpoint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrivateEndpoint {
        return
            try PrivateEndpoint(
                peer: FfiConverterString.read(from: &buf), 
                methodId: FfiConverterString.read(from: &buf), 
                endpoint: FfiConverterString.read(from: &buf), 
                createdAt: FfiConverterInt64.read(from: &buf), 
                expiresAt: FfiConverterOptionInt64.read(from: &buf)
        )
    }

    public static func write(_ value: PrivateEndpoint, into buf: inout [UInt8]) {
        FfiConverterString.write(value.peer, into: &buf)
        FfiConverterString.write(value.methodId, into: &buf)
        FfiConverterString.write(value.endpoint, into: &buf)
        FfiConverterInt64.write(value.createdAt, into: &buf)
        FfiConverterOptionInt64.write(value.expiresAt, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrivateEndpoint_lift(_ buf: RustBuffer) throws -> PrivateEndpoint {
    return try FfiConverterTypePrivateEndpoint.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrivateEndpoint_lower(_ value: PrivateEndpoint) -> RustBuffer {
    return FfiConverterTypePrivateEndpoint.lower(value)
}


/**
 * FFI-safe private endpoint offer.
 */
public struct PrivateEndpointOffer {
    public var methodId: String
    public var endpoint: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(methodId: String, endpoint: String) {
        self.methodId = methodId
        self.endpoint = endpoint
    }
}

#if compiler(>=6)
extension PrivateEndpointOffer: Sendable {}
#endif


extension PrivateEndpointOffer: Equatable, Hashable {
    public static func ==(lhs: PrivateEndpointOffer, rhs: PrivateEndpointOffer) -> Bool {
        if lhs.methodId != rhs.methodId {
            return false
        }
        if lhs.endpoint != rhs.endpoint {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(methodId)
        hasher.combine(endpoint)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePrivateEndpointOffer: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrivateEndpointOffer {
        return
            try PrivateEndpointOffer(
                methodId: FfiConverterString.read(from: &buf), 
                endpoint: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PrivateEndpointOffer, into buf: inout [UInt8]) {
        FfiConverterString.write(value.methodId, into: &buf)
        FfiConverterString.write(value.endpoint, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrivateEndpointOffer_lift(_ buf: RustBuffer) throws -> PrivateEndpointOffer {
    return try FfiConverterTypePrivateEndpointOffer.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrivateEndpointOffer_lower(_ value: PrivateEndpointOffer) -> RustBuffer {
    return FfiConverterTypePrivateEndpointOffer.lower(value)
}


/**
 * Proration result.
 */
public struct ProrationResult {
    public var creditSats: Int64
    public var chargeSats: Int64
    public var netSats: Int64
    public var isRefund: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(creditSats: Int64, chargeSats: Int64, netSats: Int64, isRefund: Bool) {
        self.creditSats = creditSats
        self.chargeSats = chargeSats
        self.netSats = netSats
        self.isRefund = isRefund
    }
}

#if compiler(>=6)
extension ProrationResult: Sendable {}
#endif


extension ProrationResult: Equatable, Hashable {
    public static func ==(lhs: ProrationResult, rhs: ProrationResult) -> Bool {
        if lhs.creditSats != rhs.creditSats {
            return false
        }
        if lhs.chargeSats != rhs.chargeSats {
            return false
        }
        if lhs.netSats != rhs.netSats {
            return false
        }
        if lhs.isRefund != rhs.isRefund {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(creditSats)
        hasher.combine(chargeSats)
        hasher.combine(netSats)
        hasher.combine(isRefund)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeProrationResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProrationResult {
        return
            try ProrationResult(
                creditSats: FfiConverterInt64.read(from: &buf), 
                chargeSats: FfiConverterInt64.read(from: &buf), 
                netSats: FfiConverterInt64.read(from: &buf), 
                isRefund: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: ProrationResult, into buf: inout [UInt8]) {
        FfiConverterInt64.write(value.creditSats, into: &buf)
        FfiConverterInt64.write(value.chargeSats, into: &buf)
        FfiConverterInt64.write(value.netSats, into: &buf)
        FfiConverterBool.write(value.isRefund, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProrationResult_lift(_ buf: RustBuffer) throws -> ProrationResult {
    return try FfiConverterTypeProrationResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProrationResult_lower(_ value: ProrationResult) -> RustBuffer {
    return FfiConverterTypeProrationResult.lower(value)
}


/**
 * Payment receipt.
 */
public struct Receipt {
    public var receiptId: String
    public var payer: String
    public var payee: String
    public var methodId: String
    public var amount: String?
    public var currency: String?
    public var createdAt: Int64
    public var metadataJson: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(receiptId: String, payer: String, payee: String, methodId: String, amount: String?, currency: String?, createdAt: Int64, metadataJson: String) {
        self.receiptId = receiptId
        self.payer = payer
        self.payee = payee
        self.methodId = methodId
        self.amount = amount
        self.currency = currency
        self.createdAt = createdAt
        self.metadataJson = metadataJson
    }
}

#if compiler(>=6)
extension Receipt: Sendable {}
#endif


extension Receipt: Equatable, Hashable {
    public static func ==(lhs: Receipt, rhs: Receipt) -> Bool {
        if lhs.receiptId != rhs.receiptId {
            return false
        }
        if lhs.payer != rhs.payer {
            return false
        }
        if lhs.payee != rhs.payee {
            return false
        }
        if lhs.methodId != rhs.methodId {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.currency != rhs.currency {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.metadataJson != rhs.metadataJson {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(receiptId)
        hasher.combine(payer)
        hasher.combine(payee)
        hasher.combine(methodId)
        hasher.combine(amount)
        hasher.combine(currency)
        hasher.combine(createdAt)
        hasher.combine(metadataJson)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeReceipt: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Receipt {
        return
            try Receipt(
                receiptId: FfiConverterString.read(from: &buf), 
                payer: FfiConverterString.read(from: &buf), 
                payee: FfiConverterString.read(from: &buf), 
                methodId: FfiConverterString.read(from: &buf), 
                amount: FfiConverterOptionString.read(from: &buf), 
                currency: FfiConverterOptionString.read(from: &buf), 
                createdAt: FfiConverterInt64.read(from: &buf), 
                metadataJson: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Receipt, into buf: inout [UInt8]) {
        FfiConverterString.write(value.receiptId, into: &buf)
        FfiConverterString.write(value.payer, into: &buf)
        FfiConverterString.write(value.payee, into: &buf)
        FfiConverterString.write(value.methodId, into: &buf)
        FfiConverterOptionString.write(value.amount, into: &buf)
        FfiConverterOptionString.write(value.currency, into: &buf)
        FfiConverterInt64.write(value.createdAt, into: &buf)
        FfiConverterString.write(value.metadataJson, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReceipt_lift(_ buf: RustBuffer) throws -> Receipt {
    return try FfiConverterTypeReceipt.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReceipt_lower(_ value: Receipt) -> RustBuffer {
    return FfiConverterTypeReceipt.lower(value)
}


/**
 * Result type for receipt generation.
 *
 * Used to communicate success/failure from mobile callbacks.
 */
public struct ReceiptGenerationResult {
    /**
     * Whether generation succeeded
     */
    public var success: Bool
    /**
     * The generated receipt (if successful)
     */
    public var receipt: ReceiptRequest?
    /**
     * Error message (if failed)
     */
    public var error: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Whether generation succeeded
         */success: Bool, 
        /**
         * The generated receipt (if successful)
         */receipt: ReceiptRequest?, 
        /**
         * Error message (if failed)
         */error: String?) {
        self.success = success
        self.receipt = receipt
        self.error = error
    }
}

#if compiler(>=6)
extension ReceiptGenerationResult: Sendable {}
#endif


extension ReceiptGenerationResult: Equatable, Hashable {
    public static func ==(lhs: ReceiptGenerationResult, rhs: ReceiptGenerationResult) -> Bool {
        if lhs.success != rhs.success {
            return false
        }
        if lhs.receipt != rhs.receipt {
            return false
        }
        if lhs.error != rhs.error {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(success)
        hasher.combine(receipt)
        hasher.combine(error)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeReceiptGenerationResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReceiptGenerationResult {
        return
            try ReceiptGenerationResult(
                success: FfiConverterBool.read(from: &buf), 
                receipt: FfiConverterOptionTypeReceiptRequest.read(from: &buf), 
                error: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ReceiptGenerationResult, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.success, into: &buf)
        FfiConverterOptionTypeReceiptRequest.write(value.receipt, into: &buf)
        FfiConverterOptionString.write(value.error, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReceiptGenerationResult_lift(_ buf: RustBuffer) throws -> ReceiptGenerationResult {
    return try FfiConverterTypeReceiptGenerationResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReceiptGenerationResult_lower(_ value: ReceiptGenerationResult) -> RustBuffer {
    return FfiConverterTypeReceiptGenerationResult.lower(value)
}


/**
 * FFI-safe receipt request.
 */
public struct ReceiptRequest {
    public var receiptId: String
    public var payer: String
    public var payee: String
    public var methodId: String
    public var amount: String?
    public var currency: String?
    public var metadataJson: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(receiptId: String, payer: String, payee: String, methodId: String, amount: String?, currency: String?, metadataJson: String) {
        self.receiptId = receiptId
        self.payer = payer
        self.payee = payee
        self.methodId = methodId
        self.amount = amount
        self.currency = currency
        self.metadataJson = metadataJson
    }
}

#if compiler(>=6)
extension ReceiptRequest: Sendable {}
#endif


extension ReceiptRequest: Equatable, Hashable {
    public static func ==(lhs: ReceiptRequest, rhs: ReceiptRequest) -> Bool {
        if lhs.receiptId != rhs.receiptId {
            return false
        }
        if lhs.payer != rhs.payer {
            return false
        }
        if lhs.payee != rhs.payee {
            return false
        }
        if lhs.methodId != rhs.methodId {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.currency != rhs.currency {
            return false
        }
        if lhs.metadataJson != rhs.metadataJson {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(receiptId)
        hasher.combine(payer)
        hasher.combine(payee)
        hasher.combine(methodId)
        hasher.combine(amount)
        hasher.combine(currency)
        hasher.combine(metadataJson)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeReceiptRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReceiptRequest {
        return
            try ReceiptRequest(
                receiptId: FfiConverterString.read(from: &buf), 
                payer: FfiConverterString.read(from: &buf), 
                payee: FfiConverterString.read(from: &buf), 
                methodId: FfiConverterString.read(from: &buf), 
                amount: FfiConverterOptionString.read(from: &buf), 
                currency: FfiConverterOptionString.read(from: &buf), 
                metadataJson: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ReceiptRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.receiptId, into: &buf)
        FfiConverterString.write(value.payer, into: &buf)
        FfiConverterString.write(value.payee, into: &buf)
        FfiConverterString.write(value.methodId, into: &buf)
        FfiConverterOptionString.write(value.amount, into: &buf)
        FfiConverterOptionString.write(value.currency, into: &buf)
        FfiConverterString.write(value.metadataJson, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReceiptRequest_lift(_ buf: RustBuffer) throws -> ReceiptRequest {
    return try FfiConverterTypeReceiptRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReceiptRequest_lower(_ value: ReceiptRequest) -> RustBuffer {
    return FfiConverterTypeReceiptRequest.lower(value)
}


/**
 * Result of scanning a QR code.
 */
public struct ScannedUri {
    /**
     * The type of URI that was scanned.
     */
    public var uriType: UriType
    /**
     * The public key if this is a Pubky URI.
     */
    public var publicKey: String?
    /**
     * The payment method if this is an Invoice URI.
     */
    public var methodId: String?
    /**
     * The invoice/endpoint data.
     */
    public var data: String?
    /**
     * The payment request ID if this is a PaymentRequest URI.
     */
    public var requestId: String?
    /**
     * The requester's public key if this is a PaymentRequest URI.
     */
    public var requester: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The type of URI that was scanned.
         */uriType: UriType, 
        /**
         * The public key if this is a Pubky URI.
         */publicKey: String?, 
        /**
         * The payment method if this is an Invoice URI.
         */methodId: String?, 
        /**
         * The invoice/endpoint data.
         */data: String?, 
        /**
         * The payment request ID if this is a PaymentRequest URI.
         */requestId: String?, 
        /**
         * The requester's public key if this is a PaymentRequest URI.
         */requester: String?) {
        self.uriType = uriType
        self.publicKey = publicKey
        self.methodId = methodId
        self.data = data
        self.requestId = requestId
        self.requester = requester
    }
}

#if compiler(>=6)
extension ScannedUri: Sendable {}
#endif


extension ScannedUri: Equatable, Hashable {
    public static func ==(lhs: ScannedUri, rhs: ScannedUri) -> Bool {
        if lhs.uriType != rhs.uriType {
            return false
        }
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.methodId != rhs.methodId {
            return false
        }
        if lhs.data != rhs.data {
            return false
        }
        if lhs.requestId != rhs.requestId {
            return false
        }
        if lhs.requester != rhs.requester {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(uriType)
        hasher.combine(publicKey)
        hasher.combine(methodId)
        hasher.combine(data)
        hasher.combine(requestId)
        hasher.combine(requester)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeScannedUri: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ScannedUri {
        return
            try ScannedUri(
                uriType: FfiConverterTypeUriType.read(from: &buf), 
                publicKey: FfiConverterOptionString.read(from: &buf), 
                methodId: FfiConverterOptionString.read(from: &buf), 
                data: FfiConverterOptionString.read(from: &buf), 
                requestId: FfiConverterOptionString.read(from: &buf), 
                requester: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ScannedUri, into buf: inout [UInt8]) {
        FfiConverterTypeUriType.write(value.uriType, into: &buf)
        FfiConverterOptionString.write(value.publicKey, into: &buf)
        FfiConverterOptionString.write(value.methodId, into: &buf)
        FfiConverterOptionString.write(value.data, into: &buf)
        FfiConverterOptionString.write(value.requestId, into: &buf)
        FfiConverterOptionString.write(value.requester, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeScannedUri_lift(_ buf: RustBuffer) throws -> ScannedUri {
    return try FfiConverterTypeScannedUri.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeScannedUri_lower(_ value: ScannedUri) -> RustBuffer {
    return FfiConverterTypeScannedUri.lower(value)
}


/**
 * Selection preferences.
 */
public struct SelectionPreferences {
    public var strategy: SelectionStrategy
    public var excludedMethods: [String]
    public var maxFeeSats: UInt64?
    public var maxConfirmationTimeSecs: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(strategy: SelectionStrategy, excludedMethods: [String], maxFeeSats: UInt64?, maxConfirmationTimeSecs: UInt64?) {
        self.strategy = strategy
        self.excludedMethods = excludedMethods
        self.maxFeeSats = maxFeeSats
        self.maxConfirmationTimeSecs = maxConfirmationTimeSecs
    }
}

#if compiler(>=6)
extension SelectionPreferences: Sendable {}
#endif


extension SelectionPreferences: Equatable, Hashable {
    public static func ==(lhs: SelectionPreferences, rhs: SelectionPreferences) -> Bool {
        if lhs.strategy != rhs.strategy {
            return false
        }
        if lhs.excludedMethods != rhs.excludedMethods {
            return false
        }
        if lhs.maxFeeSats != rhs.maxFeeSats {
            return false
        }
        if lhs.maxConfirmationTimeSecs != rhs.maxConfirmationTimeSecs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(strategy)
        hasher.combine(excludedMethods)
        hasher.combine(maxFeeSats)
        hasher.combine(maxConfirmationTimeSecs)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSelectionPreferences: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SelectionPreferences {
        return
            try SelectionPreferences(
                strategy: FfiConverterTypeSelectionStrategy.read(from: &buf), 
                excludedMethods: FfiConverterSequenceString.read(from: &buf), 
                maxFeeSats: FfiConverterOptionUInt64.read(from: &buf), 
                maxConfirmationTimeSecs: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: SelectionPreferences, into buf: inout [UInt8]) {
        FfiConverterTypeSelectionStrategy.write(value.strategy, into: &buf)
        FfiConverterSequenceString.write(value.excludedMethods, into: &buf)
        FfiConverterOptionUInt64.write(value.maxFeeSats, into: &buf)
        FfiConverterOptionUInt64.write(value.maxConfirmationTimeSecs, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSelectionPreferences_lift(_ buf: RustBuffer) throws -> SelectionPreferences {
    return try FfiConverterTypeSelectionPreferences.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSelectionPreferences_lower(_ value: SelectionPreferences) -> RustBuffer {
    return FfiConverterTypeSelectionPreferences.lower(value)
}


/**
 * Result of payment method selection.
 */
public struct SelectionResult {
    public var primaryMethod: String
    public var fallbackMethods: [String]
    public var reason: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(primaryMethod: String, fallbackMethods: [String], reason: String) {
        self.primaryMethod = primaryMethod
        self.fallbackMethods = fallbackMethods
        self.reason = reason
    }
}

#if compiler(>=6)
extension SelectionResult: Sendable {}
#endif


extension SelectionResult: Equatable, Hashable {
    public static func ==(lhs: SelectionResult, rhs: SelectionResult) -> Bool {
        if lhs.primaryMethod != rhs.primaryMethod {
            return false
        }
        if lhs.fallbackMethods != rhs.fallbackMethods {
            return false
        }
        if lhs.reason != rhs.reason {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(primaryMethod)
        hasher.combine(fallbackMethods)
        hasher.combine(reason)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSelectionResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SelectionResult {
        return
            try SelectionResult(
                primaryMethod: FfiConverterString.read(from: &buf), 
                fallbackMethods: FfiConverterSequenceString.read(from: &buf), 
                reason: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: SelectionResult, into buf: inout [UInt8]) {
        FfiConverterString.write(value.primaryMethod, into: &buf)
        FfiConverterSequenceString.write(value.fallbackMethods, into: &buf)
        FfiConverterString.write(value.reason, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSelectionResult_lift(_ buf: RustBuffer) throws -> SelectionResult {
    return try FfiConverterTypeSelectionResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSelectionResult_lower(_ value: SelectionResult) -> RustBuffer {
    return FfiConverterTypeSelectionResult.lower(value)
}


/**
 * Result of checking if amount would exceed limit.
 */
public struct SpendingCheckResultFfi {
    /**
     * Whether the amount would exceed the limit
     */
    public var wouldExceed: Bool
    /**
     * Current spent amount in satoshis
     */
    public var currentSpentSats: Int64
    /**
     * Remaining limit in satoshis
     */
    public var remainingSats: Int64
    /**
     * Amount being checked in satoshis
     */
    public var checkAmountSats: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Whether the amount would exceed the limit
         */wouldExceed: Bool, 
        /**
         * Current spent amount in satoshis
         */currentSpentSats: Int64, 
        /**
         * Remaining limit in satoshis
         */remainingSats: Int64, 
        /**
         * Amount being checked in satoshis
         */checkAmountSats: Int64) {
        self.wouldExceed = wouldExceed
        self.currentSpentSats = currentSpentSats
        self.remainingSats = remainingSats
        self.checkAmountSats = checkAmountSats
    }
}

#if compiler(>=6)
extension SpendingCheckResultFfi: Sendable {}
#endif


extension SpendingCheckResultFfi: Equatable, Hashable {
    public static func ==(lhs: SpendingCheckResultFfi, rhs: SpendingCheckResultFfi) -> Bool {
        if lhs.wouldExceed != rhs.wouldExceed {
            return false
        }
        if lhs.currentSpentSats != rhs.currentSpentSats {
            return false
        }
        if lhs.remainingSats != rhs.remainingSats {
            return false
        }
        if lhs.checkAmountSats != rhs.checkAmountSats {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(wouldExceed)
        hasher.combine(currentSpentSats)
        hasher.combine(remainingSats)
        hasher.combine(checkAmountSats)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSpendingCheckResultFFI: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SpendingCheckResultFfi {
        return
            try SpendingCheckResultFfi(
                wouldExceed: FfiConverterBool.read(from: &buf), 
                currentSpentSats: FfiConverterInt64.read(from: &buf), 
                remainingSats: FfiConverterInt64.read(from: &buf), 
                checkAmountSats: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: SpendingCheckResultFfi, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.wouldExceed, into: &buf)
        FfiConverterInt64.write(value.currentSpentSats, into: &buf)
        FfiConverterInt64.write(value.remainingSats, into: &buf)
        FfiConverterInt64.write(value.checkAmountSats, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSpendingCheckResultFFI_lift(_ buf: RustBuffer) throws -> SpendingCheckResultFfi {
    return try FfiConverterTypeSpendingCheckResultFFI.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSpendingCheckResultFFI_lower(_ value: SpendingCheckResultFfi) -> RustBuffer {
    return FfiConverterTypeSpendingCheckResultFFI.lower(value)
}


/**
 * FFI-safe spending reservation token.
 *
 * Returned by `try_reserve_spending()` and must be either committed
 * or rolled back after payment execution.
 */
public struct SpendingReservationFfi {
    /**
     * Unique identifier for this reservation
     */
    public var reservationId: String
    /**
     * Peer public key (z-base32 encoded)
     */
    public var peerPubkey: String
    /**
     * Reserved amount in satoshis
     */
    public var amountSats: Int64
    /**
     * Unix timestamp when reservation was created
     */
    public var createdAt: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique identifier for this reservation
         */reservationId: String, 
        /**
         * Peer public key (z-base32 encoded)
         */peerPubkey: String, 
        /**
         * Reserved amount in satoshis
         */amountSats: Int64, 
        /**
         * Unix timestamp when reservation was created
         */createdAt: Int64) {
        self.reservationId = reservationId
        self.peerPubkey = peerPubkey
        self.amountSats = amountSats
        self.createdAt = createdAt
    }
}

#if compiler(>=6)
extension SpendingReservationFfi: Sendable {}
#endif


extension SpendingReservationFfi: Equatable, Hashable {
    public static func ==(lhs: SpendingReservationFfi, rhs: SpendingReservationFfi) -> Bool {
        if lhs.reservationId != rhs.reservationId {
            return false
        }
        if lhs.peerPubkey != rhs.peerPubkey {
            return false
        }
        if lhs.amountSats != rhs.amountSats {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(reservationId)
        hasher.combine(peerPubkey)
        hasher.combine(amountSats)
        hasher.combine(createdAt)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSpendingReservationFFI: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SpendingReservationFfi {
        return
            try SpendingReservationFfi(
                reservationId: FfiConverterString.read(from: &buf), 
                peerPubkey: FfiConverterString.read(from: &buf), 
                amountSats: FfiConverterInt64.read(from: &buf), 
                createdAt: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: SpendingReservationFfi, into buf: inout [UInt8]) {
        FfiConverterString.write(value.reservationId, into: &buf)
        FfiConverterString.write(value.peerPubkey, into: &buf)
        FfiConverterInt64.write(value.amountSats, into: &buf)
        FfiConverterInt64.write(value.createdAt, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSpendingReservationFFI_lift(_ buf: RustBuffer) throws -> SpendingReservationFfi {
    return try FfiConverterTypeSpendingReservationFFI.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSpendingReservationFFI_lower(_ value: SpendingReservationFfi) -> RustBuffer {
    return FfiConverterTypeSpendingReservationFFI.lower(value)
}


/**
 * Result type for storage get operations.
 */
public struct StorageGetResult {
    /**
     * Whether the operation succeeded
     */
    public var success: Bool
    /**
     * The content if found (None if not found but successful)
     */
    public var content: String?
    /**
     * Error message if failed
     */
    public var error: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Whether the operation succeeded
         */success: Bool, 
        /**
         * The content if found (None if not found but successful)
         */content: String?, 
        /**
         * Error message if failed
         */error: String?) {
        self.success = success
        self.content = content
        self.error = error
    }
}

#if compiler(>=6)
extension StorageGetResult: Sendable {}
#endif


extension StorageGetResult: Equatable, Hashable {
    public static func ==(lhs: StorageGetResult, rhs: StorageGetResult) -> Bool {
        if lhs.success != rhs.success {
            return false
        }
        if lhs.content != rhs.content {
            return false
        }
        if lhs.error != rhs.error {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(success)
        hasher.combine(content)
        hasher.combine(error)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeStorageGetResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StorageGetResult {
        return
            try StorageGetResult(
                success: FfiConverterBool.read(from: &buf), 
                content: FfiConverterOptionString.read(from: &buf), 
                error: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: StorageGetResult, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.success, into: &buf)
        FfiConverterOptionString.write(value.content, into: &buf)
        FfiConverterOptionString.write(value.error, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStorageGetResult_lift(_ buf: RustBuffer) throws -> StorageGetResult {
    return try FfiConverterTypeStorageGetResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStorageGetResult_lower(_ value: StorageGetResult) -> RustBuffer {
    return FfiConverterTypeStorageGetResult.lower(value)
}


/**
 * Result type for storage list operations.
 */
public struct StorageListResult {
    /**
     * Whether the operation succeeded
     */
    public var success: Bool
    /**
     * List of file names/paths
     */
    public var entries: [String]
    /**
     * Error message if failed
     */
    public var error: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Whether the operation succeeded
         */success: Bool, 
        /**
         * List of file names/paths
         */entries: [String], 
        /**
         * Error message if failed
         */error: String?) {
        self.success = success
        self.entries = entries
        self.error = error
    }
}

#if compiler(>=6)
extension StorageListResult: Sendable {}
#endif


extension StorageListResult: Equatable, Hashable {
    public static func ==(lhs: StorageListResult, rhs: StorageListResult) -> Bool {
        if lhs.success != rhs.success {
            return false
        }
        if lhs.entries != rhs.entries {
            return false
        }
        if lhs.error != rhs.error {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(success)
        hasher.combine(entries)
        hasher.combine(error)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeStorageListResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StorageListResult {
        return
            try StorageListResult(
                success: FfiConverterBool.read(from: &buf), 
                entries: FfiConverterSequenceString.read(from: &buf), 
                error: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: StorageListResult, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.success, into: &buf)
        FfiConverterSequenceString.write(value.entries, into: &buf)
        FfiConverterOptionString.write(value.error, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStorageListResult_lift(_ buf: RustBuffer) throws -> StorageListResult {
    return try FfiConverterTypeStorageListResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStorageListResult_lower(_ value: StorageListResult) -> RustBuffer {
    return FfiConverterTypeStorageListResult.lower(value)
}


/**
 * Result type for storage operations.
 */
public struct StorageOperationResult {
    /**
     * Whether the operation succeeded
     */
    public var success: Bool
    /**
     * Error message if failed
     */
    public var error: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Whether the operation succeeded
         */success: Bool, 
        /**
         * Error message if failed
         */error: String?) {
        self.success = success
        self.error = error
    }
}

#if compiler(>=6)
extension StorageOperationResult: Sendable {}
#endif


extension StorageOperationResult: Equatable, Hashable {
    public static func ==(lhs: StorageOperationResult, rhs: StorageOperationResult) -> Bool {
        if lhs.success != rhs.success {
            return false
        }
        if lhs.error != rhs.error {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(success)
        hasher.combine(error)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeStorageOperationResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StorageOperationResult {
        return
            try StorageOperationResult(
                success: FfiConverterBool.read(from: &buf), 
                error: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: StorageOperationResult, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.success, into: &buf)
        FfiConverterOptionString.write(value.error, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStorageOperationResult_lift(_ buf: RustBuffer) throws -> StorageOperationResult {
    return try FfiConverterTypeStorageOperationResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStorageOperationResult_lower(_ value: StorageOperationResult) -> RustBuffer {
    return FfiConverterTypeStorageOperationResult.lower(value)
}


/**
 * Subscription information.
 */
public struct Subscription {
    public var subscriptionId: String
    public var subscriber: String
    public var provider: String
    public var terms: SubscriptionTerms
    public var createdAt: Int64
    public var startsAt: Int64
    public var endsAt: Int64?
    public var isActive: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(subscriptionId: String, subscriber: String, provider: String, terms: SubscriptionTerms, createdAt: Int64, startsAt: Int64, endsAt: Int64?, isActive: Bool) {
        self.subscriptionId = subscriptionId
        self.subscriber = subscriber
        self.provider = provider
        self.terms = terms
        self.createdAt = createdAt
        self.startsAt = startsAt
        self.endsAt = endsAt
        self.isActive = isActive
    }
}

#if compiler(>=6)
extension Subscription: Sendable {}
#endif


extension Subscription: Equatable, Hashable {
    public static func ==(lhs: Subscription, rhs: Subscription) -> Bool {
        if lhs.subscriptionId != rhs.subscriptionId {
            return false
        }
        if lhs.subscriber != rhs.subscriber {
            return false
        }
        if lhs.provider != rhs.provider {
            return false
        }
        if lhs.terms != rhs.terms {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.startsAt != rhs.startsAt {
            return false
        }
        if lhs.endsAt != rhs.endsAt {
            return false
        }
        if lhs.isActive != rhs.isActive {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(subscriptionId)
        hasher.combine(subscriber)
        hasher.combine(provider)
        hasher.combine(terms)
        hasher.combine(createdAt)
        hasher.combine(startsAt)
        hasher.combine(endsAt)
        hasher.combine(isActive)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSubscription: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Subscription {
        return
            try Subscription(
                subscriptionId: FfiConverterString.read(from: &buf), 
                subscriber: FfiConverterString.read(from: &buf), 
                provider: FfiConverterString.read(from: &buf), 
                terms: FfiConverterTypeSubscriptionTerms.read(from: &buf), 
                createdAt: FfiConverterInt64.read(from: &buf), 
                startsAt: FfiConverterInt64.read(from: &buf), 
                endsAt: FfiConverterOptionInt64.read(from: &buf), 
                isActive: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: Subscription, into buf: inout [UInt8]) {
        FfiConverterString.write(value.subscriptionId, into: &buf)
        FfiConverterString.write(value.subscriber, into: &buf)
        FfiConverterString.write(value.provider, into: &buf)
        FfiConverterTypeSubscriptionTerms.write(value.terms, into: &buf)
        FfiConverterInt64.write(value.createdAt, into: &buf)
        FfiConverterInt64.write(value.startsAt, into: &buf)
        FfiConverterOptionInt64.write(value.endsAt, into: &buf)
        FfiConverterBool.write(value.isActive, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSubscription_lift(_ buf: RustBuffer) throws -> Subscription {
    return try FfiConverterTypeSubscription.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSubscription_lower(_ value: Subscription) -> RustBuffer {
    return FfiConverterTypeSubscription.lower(value)
}


/**
 * Subscription terms.
 */
public struct SubscriptionTerms {
    public var amountSats: Int64
    public var currency: String
    public var frequency: PaymentFrequency
    public var methodId: String
    public var description: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(amountSats: Int64, currency: String, frequency: PaymentFrequency, methodId: String, description: String) {
        self.amountSats = amountSats
        self.currency = currency
        self.frequency = frequency
        self.methodId = methodId
        self.description = description
    }
}

#if compiler(>=6)
extension SubscriptionTerms: Sendable {}
#endif


extension SubscriptionTerms: Equatable, Hashable {
    public static func ==(lhs: SubscriptionTerms, rhs: SubscriptionTerms) -> Bool {
        if lhs.amountSats != rhs.amountSats {
            return false
        }
        if lhs.currency != rhs.currency {
            return false
        }
        if lhs.frequency != rhs.frequency {
            return false
        }
        if lhs.methodId != rhs.methodId {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amountSats)
        hasher.combine(currency)
        hasher.combine(frequency)
        hasher.combine(methodId)
        hasher.combine(description)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSubscriptionTerms: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SubscriptionTerms {
        return
            try SubscriptionTerms(
                amountSats: FfiConverterInt64.read(from: &buf), 
                currency: FfiConverterString.read(from: &buf), 
                frequency: FfiConverterTypePaymentFrequency.read(from: &buf), 
                methodId: FfiConverterString.read(from: &buf), 
                description: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: SubscriptionTerms, into buf: inout [UInt8]) {
        FfiConverterInt64.write(value.amountSats, into: &buf)
        FfiConverterString.write(value.currency, into: &buf)
        FfiConverterTypePaymentFrequency.write(value.frequency, into: &buf)
        FfiConverterString.write(value.methodId, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSubscriptionTerms_lift(_ buf: RustBuffer) throws -> SubscriptionTerms {
    return try FfiConverterTypeSubscriptionTerms.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSubscriptionTerms_lower(_ value: SubscriptionTerms) -> RustBuffer {
    return FfiConverterTypeSubscriptionTerms.lower(value)
}


/**
 * FFI-safe sync result.
 */
public struct SyncResultFfi {
    public var total: UInt32
    public var added: UInt32
    public var removed: UInt32
    public var syncedAt: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(total: UInt32, added: UInt32, removed: UInt32, syncedAt: Int64) {
        self.total = total
        self.added = added
        self.removed = removed
        self.syncedAt = syncedAt
    }
}

#if compiler(>=6)
extension SyncResultFfi: Sendable {}
#endif


extension SyncResultFfi: Equatable, Hashable {
    public static func ==(lhs: SyncResultFfi, rhs: SyncResultFfi) -> Bool {
        if lhs.total != rhs.total {
            return false
        }
        if lhs.added != rhs.added {
            return false
        }
        if lhs.removed != rhs.removed {
            return false
        }
        if lhs.syncedAt != rhs.syncedAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(total)
        hasher.combine(added)
        hasher.combine(removed)
        hasher.combine(syncedAt)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSyncResultFFI: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SyncResultFfi {
        return
            try SyncResultFfi(
                total: FfiConverterUInt32.read(from: &buf), 
                added: FfiConverterUInt32.read(from: &buf), 
                removed: FfiConverterUInt32.read(from: &buf), 
                syncedAt: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: SyncResultFfi, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.total, into: &buf)
        FfiConverterUInt32.write(value.added, into: &buf)
        FfiConverterUInt32.write(value.removed, into: &buf)
        FfiConverterInt64.write(value.syncedAt, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncResultFFI_lift(_ buf: RustBuffer) throws -> SyncResultFfi {
    return try FfiConverterTypeSyncResultFFI.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncResultFFI_lower(_ value: SyncResultFfi) -> RustBuffer {
    return FfiConverterTypeSyncResultFFI.lower(value)
}


/**
 * Derived X25519 keypair for Noise protocol.
 */
public struct X25519Keypair {
    /**
     * Secret key - 32 bytes, hex encoded.
     */
    public var secretKeyHex: String
    /**
     * Public key - 32 bytes, hex encoded.
     */
    public var publicKeyHex: String
    /**
     * Device ID used for derivation.
     */
    public var deviceId: String
    /**
     * Epoch used for derivation.
     */
    public var epoch: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Secret key - 32 bytes, hex encoded.
         */secretKeyHex: String, 
        /**
         * Public key - 32 bytes, hex encoded.
         */publicKeyHex: String, 
        /**
         * Device ID used for derivation.
         */deviceId: String, 
        /**
         * Epoch used for derivation.
         */epoch: UInt32) {
        self.secretKeyHex = secretKeyHex
        self.publicKeyHex = publicKeyHex
        self.deviceId = deviceId
        self.epoch = epoch
    }
}

#if compiler(>=6)
extension X25519Keypair: Sendable {}
#endif


extension X25519Keypair: Equatable, Hashable {
    public static func ==(lhs: X25519Keypair, rhs: X25519Keypair) -> Bool {
        if lhs.secretKeyHex != rhs.secretKeyHex {
            return false
        }
        if lhs.publicKeyHex != rhs.publicKeyHex {
            return false
        }
        if lhs.deviceId != rhs.deviceId {
            return false
        }
        if lhs.epoch != rhs.epoch {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretKeyHex)
        hasher.combine(publicKeyHex)
        hasher.combine(deviceId)
        hasher.combine(epoch)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeX25519Keypair: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> X25519Keypair {
        return
            try X25519Keypair(
                secretKeyHex: FfiConverterString.read(from: &buf), 
                publicKeyHex: FfiConverterString.read(from: &buf), 
                deviceId: FfiConverterString.read(from: &buf), 
                epoch: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: X25519Keypair, into buf: inout [UInt8]) {
        FfiConverterString.write(value.secretKeyHex, into: &buf)
        FfiConverterString.write(value.publicKeyHex, into: &buf)
        FfiConverterString.write(value.deviceId, into: &buf)
        FfiConverterUInt32.write(value.epoch, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeX25519Keypair_lift(_ buf: RustBuffer) throws -> X25519Keypair {
    return try FfiConverterTypeX25519Keypair.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeX25519Keypair_lower(_ value: X25519Keypair) -> RustBuffer {
    return FfiConverterTypeX25519Keypair.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Bitcoin network types (FFI-compatible).
 *
 * Used to configure which Bitcoin network the wallet operates on.
 */

public enum BitcoinNetworkFfi {
    
    /**
     * Bitcoin mainnet (real money).
     */
    case mainnet
    /**
     * Bitcoin testnet (test coins).
     */
    case testnet
    /**
     * Bitcoin regtest (local development).
     */
    case regtest
}


#if compiler(>=6)
extension BitcoinNetworkFfi: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBitcoinNetworkFFI: FfiConverterRustBuffer {
    typealias SwiftType = BitcoinNetworkFfi

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BitcoinNetworkFfi {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .mainnet
        
        case 2: return .testnet
        
        case 3: return .regtest
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BitcoinNetworkFfi, into buf: inout [UInt8]) {
        switch value {
        
        
        case .mainnet:
            writeInt(&buf, Int32(1))
        
        
        case .testnet:
            writeInt(&buf, Int32(2))
        
        
        case .regtest:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBitcoinNetworkFFI_lift(_ buf: RustBuffer) throws -> BitcoinNetworkFfi {
    return try FfiConverterTypeBitcoinNetworkFFI.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBitcoinNetworkFFI_lower(_ value: BitcoinNetworkFfi) -> RustBuffer {
    return FfiConverterTypeBitcoinNetworkFFI.lower(value)
}


extension BitcoinNetworkFfi: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Health status of a payment method.
 */

public enum HealthStatus {
    
    case healthy
    case degraded
    case unavailable
    case unknown
}


#if compiler(>=6)
extension HealthStatus: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHealthStatus: FfiConverterRustBuffer {
    typealias SwiftType = HealthStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HealthStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .healthy
        
        case 2: return .degraded
        
        case 3: return .unavailable
        
        case 4: return .unknown
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HealthStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .healthy:
            writeInt(&buf, Int32(1))
        
        
        case .degraded:
            writeInt(&buf, Int32(2))
        
        
        case .unavailable:
            writeInt(&buf, Int32(3))
        
        
        case .unknown:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHealthStatus_lift(_ buf: RustBuffer) throws -> HealthStatus {
    return try FfiConverterTypeHealthStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHealthStatus_lower(_ value: HealthStatus) -> RustBuffer {
    return FfiConverterTypeHealthStatus.lower(value)
}


extension HealthStatus: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Lightning network types (FFI-compatible).
 *
 * Used to configure which Lightning network the wallet operates on.
 */

public enum LightningNetworkFfi {
    
    /**
     * Lightning mainnet (real money).
     */
    case mainnet
    /**
     * Lightning testnet (test coins).
     */
    case testnet
    /**
     * Lightning regtest (local development).
     */
    case regtest
}


#if compiler(>=6)
extension LightningNetworkFfi: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLightningNetworkFFI: FfiConverterRustBuffer {
    typealias SwiftType = LightningNetworkFfi

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LightningNetworkFfi {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .mainnet
        
        case 2: return .testnet
        
        case 3: return .regtest
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LightningNetworkFfi, into buf: inout [UInt8]) {
        switch value {
        
        
        case .mainnet:
            writeInt(&buf, Int32(1))
        
        
        case .testnet:
            writeInt(&buf, Int32(2))
        
        
        case .regtest:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLightningNetworkFFI_lift(_ buf: RustBuffer) throws -> LightningNetworkFfi {
    return try FfiConverterTypeLightningNetworkFFI.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLightningNetworkFFI_lower(_ value: LightningNetworkFfi) -> RustBuffer {
    return FfiConverterTypeLightningNetworkFFI.lower(value)
}


extension LightningNetworkFfi: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Status of a Lightning payment (FFI-compatible).
 */

public enum LightningPaymentStatusFfi {
    
    /**
     * Payment succeeded.
     */
    case succeeded
    /**
     * Payment is pending/in-flight.
     */
    case pending
    /**
     * Payment failed.
     */
    case failed
}


#if compiler(>=6)
extension LightningPaymentStatusFfi: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLightningPaymentStatusFFI: FfiConverterRustBuffer {
    typealias SwiftType = LightningPaymentStatusFfi

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LightningPaymentStatusFfi {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .succeeded
        
        case 2: return .pending
        
        case 3: return .failed
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LightningPaymentStatusFfi, into buf: inout [UInt8]) {
        switch value {
        
        
        case .succeeded:
            writeInt(&buf, Int32(1))
        
        
        case .pending:
            writeInt(&buf, Int32(2))
        
        
        case .failed:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLightningPaymentStatusFFI_lift(_ buf: RustBuffer) throws -> LightningPaymentStatusFfi {
    return try FfiConverterTypeLightningPaymentStatusFFI.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLightningPaymentStatusFFI_lower(_ value: LightningPaymentStatusFfi) -> RustBuffer {
    return FfiConverterTypeLightningPaymentStatusFFI.lower(value)
}


extension LightningPaymentStatusFfi: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Modification type for subscriptions.
 */

public enum ModificationType {
    
    case upgrade(newAmountSats: Int64, effectiveDate: Int64
    )
    case downgrade(newAmountSats: Int64, effectiveDate: Int64
    )
    case changeMethod(newMethodId: String
    )
    case changeBillingDate(newDay: UInt8
    )
    case cancel(effectiveDate: Int64, reason: String?
    )
    case pause(resumeDate: Int64
    )
    case resume
}


#if compiler(>=6)
extension ModificationType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeModificationType: FfiConverterRustBuffer {
    typealias SwiftType = ModificationType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ModificationType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .upgrade(newAmountSats: try FfiConverterInt64.read(from: &buf), effectiveDate: try FfiConverterInt64.read(from: &buf)
        )
        
        case 2: return .downgrade(newAmountSats: try FfiConverterInt64.read(from: &buf), effectiveDate: try FfiConverterInt64.read(from: &buf)
        )
        
        case 3: return .changeMethod(newMethodId: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .changeBillingDate(newDay: try FfiConverterUInt8.read(from: &buf)
        )
        
        case 5: return .cancel(effectiveDate: try FfiConverterInt64.read(from: &buf), reason: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 6: return .pause(resumeDate: try FfiConverterInt64.read(from: &buf)
        )
        
        case 7: return .resume
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ModificationType, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .upgrade(newAmountSats,effectiveDate):
            writeInt(&buf, Int32(1))
            FfiConverterInt64.write(newAmountSats, into: &buf)
            FfiConverterInt64.write(effectiveDate, into: &buf)
            
        
        case let .downgrade(newAmountSats,effectiveDate):
            writeInt(&buf, Int32(2))
            FfiConverterInt64.write(newAmountSats, into: &buf)
            FfiConverterInt64.write(effectiveDate, into: &buf)
            
        
        case let .changeMethod(newMethodId):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(newMethodId, into: &buf)
            
        
        case let .changeBillingDate(newDay):
            writeInt(&buf, Int32(4))
            FfiConverterUInt8.write(newDay, into: &buf)
            
        
        case let .cancel(effectiveDate,reason):
            writeInt(&buf, Int32(5))
            FfiConverterInt64.write(effectiveDate, into: &buf)
            FfiConverterOptionString.write(reason, into: &buf)
            
        
        case let .pause(resumeDate):
            writeInt(&buf, Int32(6))
            FfiConverterInt64.write(resumeDate, into: &buf)
            
        
        case .resume:
            writeInt(&buf, Int32(7))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeModificationType_lift(_ buf: RustBuffer) throws -> ModificationType {
    return try FfiConverterTypeModificationType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeModificationType_lower(_ value: ModificationType) -> RustBuffer {
    return FfiConverterTypeModificationType.lower(value)
}


extension ModificationType: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Status of a Noise connection.
 */

public enum NoiseConnectionStatus {
    
    /**
     * Not connected.
     */
    case disconnected
    /**
     * Connecting to server.
     */
    case connecting
    /**
     * Handshake in progress.
     */
    case handshaking
    /**
     * Connected and ready for communication.
     */
    case connected
    /**
     * Connection failed.
     */
    case failed
}


#if compiler(>=6)
extension NoiseConnectionStatus: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNoiseConnectionStatus: FfiConverterRustBuffer {
    typealias SwiftType = NoiseConnectionStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NoiseConnectionStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .disconnected
        
        case 2: return .connecting
        
        case 3: return .handshaking
        
        case 4: return .connected
        
        case 5: return .failed
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NoiseConnectionStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .disconnected:
            writeInt(&buf, Int32(1))
        
        
        case .connecting:
            writeInt(&buf, Int32(2))
        
        
        case .handshaking:
            writeInt(&buf, Int32(3))
        
        
        case .connected:
            writeInt(&buf, Int32(4))
        
        
        case .failed:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNoiseConnectionStatus_lift(_ buf: RustBuffer) throws -> NoiseConnectionStatus {
    return try FfiConverterTypeNoiseConnectionStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNoiseConnectionStatus_lower(_ value: NoiseConnectionStatus) -> RustBuffer {
    return FfiConverterTypeNoiseConnectionStatus.lower(value)
}


extension NoiseConnectionStatus: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Type of payment message exchanged over Noise channel.
 */

public enum NoisePaymentMessageType {
    
    /**
     * Request a receipt for a payment.
     */
    case receiptRequest
    /**
     * Confirm receipt of payment.
     */
    case receiptConfirmation
    /**
     * Offer a private endpoint.
     */
    case privateEndpointOffer
    /**
     * Error response.
     */
    case error
    /**
     * Ping for connection keep-alive.
     */
    case ping
    /**
     * Pong response to ping.
     */
    case pong
}


#if compiler(>=6)
extension NoisePaymentMessageType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNoisePaymentMessageType: FfiConverterRustBuffer {
    typealias SwiftType = NoisePaymentMessageType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NoisePaymentMessageType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .receiptRequest
        
        case 2: return .receiptConfirmation
        
        case 3: return .privateEndpointOffer
        
        case 4: return .error
        
        case 5: return .ping
        
        case 6: return .pong
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NoisePaymentMessageType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .receiptRequest:
            writeInt(&buf, Int32(1))
        
        
        case .receiptConfirmation:
            writeInt(&buf, Int32(2))
        
        
        case .privateEndpointOffer:
            writeInt(&buf, Int32(3))
        
        
        case .error:
            writeInt(&buf, Int32(4))
        
        
        case .ping:
            writeInt(&buf, Int32(5))
        
        
        case .pong:
            writeInt(&buf, Int32(6))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNoisePaymentMessageType_lift(_ buf: RustBuffer) throws -> NoisePaymentMessageType {
    return try FfiConverterTypeNoisePaymentMessageType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNoisePaymentMessageType_lower(_ value: NoisePaymentMessageType) -> RustBuffer {
    return FfiConverterTypeNoisePaymentMessageType.lower(value)
}


extension NoisePaymentMessageType: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Parsed Paykit message.
 */

public enum ParsedMessage {
    
    case offerPrivateEndpoint(offer: PrivateEndpointOffer
    )
    case requestReceipt(request: ReceiptRequest
    )
    case confirmReceipt(receipt: ReceiptRequest
    )
    case ack
    case error(error: ErrorMessage
    )
}


#if compiler(>=6)
extension ParsedMessage: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeParsedMessage: FfiConverterRustBuffer {
    typealias SwiftType = ParsedMessage

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ParsedMessage {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .offerPrivateEndpoint(offer: try FfiConverterTypePrivateEndpointOffer.read(from: &buf)
        )
        
        case 2: return .requestReceipt(request: try FfiConverterTypeReceiptRequest.read(from: &buf)
        )
        
        case 3: return .confirmReceipt(receipt: try FfiConverterTypeReceiptRequest.read(from: &buf)
        )
        
        case 4: return .ack
        
        case 5: return .error(error: try FfiConverterTypeErrorMessage.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ParsedMessage, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .offerPrivateEndpoint(offer):
            writeInt(&buf, Int32(1))
            FfiConverterTypePrivateEndpointOffer.write(offer, into: &buf)
            
        
        case let .requestReceipt(request):
            writeInt(&buf, Int32(2))
            FfiConverterTypeReceiptRequest.write(request, into: &buf)
            
        
        case let .confirmReceipt(receipt):
            writeInt(&buf, Int32(3))
            FfiConverterTypeReceiptRequest.write(receipt, into: &buf)
            
        
        case .ack:
            writeInt(&buf, Int32(4))
        
        
        case let .error(error):
            writeInt(&buf, Int32(5))
            FfiConverterTypeErrorMessage.write(error, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParsedMessage_lift(_ buf: RustBuffer) throws -> ParsedMessage {
    return try FfiConverterTypeParsedMessage.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParsedMessage_lower(_ value: ParsedMessage) -> RustBuffer {
    return FfiConverterTypeParsedMessage.lower(value)
}


extension ParsedMessage: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * FFI-safe Paykit message type.
 */

public enum PaykitMessageType {
    
    /**
     * Offer a private endpoint.
     */
    case offerPrivateEndpoint
    /**
     * Request a receipt.
     */
    case requestReceipt
    /**
     * Confirm a receipt.
     */
    case confirmReceipt
    /**
     * Acknowledgment.
     */
    case ack
    /**
     * Error message.
     */
    case error
}


#if compiler(>=6)
extension PaykitMessageType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaykitMessageType: FfiConverterRustBuffer {
    typealias SwiftType = PaykitMessageType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaykitMessageType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .offerPrivateEndpoint
        
        case 2: return .requestReceipt
        
        case 3: return .confirmReceipt
        
        case 4: return .ack
        
        case 5: return .error
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaykitMessageType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .offerPrivateEndpoint:
            writeInt(&buf, Int32(1))
        
        
        case .requestReceipt:
            writeInt(&buf, Int32(2))
        
        
        case .confirmReceipt:
            writeInt(&buf, Int32(3))
        
        
        case .ack:
            writeInt(&buf, Int32(4))
        
        
        case .error:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaykitMessageType_lift(_ buf: RustBuffer) throws -> PaykitMessageType {
    return try FfiConverterTypePaykitMessageType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaykitMessageType_lower(_ value: PaykitMessageType) -> RustBuffer {
    return FfiConverterTypePaykitMessageType.lower(value)
}


extension PaykitMessageType: Equatable, Hashable {}







/**
 * Mobile-friendly error type.
 */
public enum PaykitMobileError: Swift.Error {

    
    
    /**
     * Transport layer error (network, I/O).
     */
    case Transport(msg: String
    )
    /**
     * Validation error (invalid input, format).
     */
    case Validation(msg: String
    )
    /**
     * Resource not found.
     */
    case NotFound(msg: String
    )
    /**
     * Serialization/deserialization error.
     */
    case Serialization(msg: String
    )
    /**
     * Internal error (unexpected state).
     */
    case Internal(msg: String
    )
    /**
     * Network timeout error.
     */
    case NetworkTimeout(msg: String
    )
    /**
     * Connection refused or failed.
     */
    case ConnectionError(msg: String
    )
    /**
     * Authentication failed.
     */
    case AuthenticationError(msg: String
    )
    /**
     * Session expired or invalid.
     */
    case SessionError(msg: String
    )
    /**
     * Rate limit exceeded.
     */
    case RateLimitError(msg: String
    )
    /**
     * Permission denied.
     */
    case PermissionDenied(msg: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaykitMobileError: FfiConverterRustBuffer {
    typealias SwiftType = PaykitMobileError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaykitMobileError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Transport(
            msg: try FfiConverterString.read(from: &buf)
            )
        case 2: return .Validation(
            msg: try FfiConverterString.read(from: &buf)
            )
        case 3: return .NotFound(
            msg: try FfiConverterString.read(from: &buf)
            )
        case 4: return .Serialization(
            msg: try FfiConverterString.read(from: &buf)
            )
        case 5: return .Internal(
            msg: try FfiConverterString.read(from: &buf)
            )
        case 6: return .NetworkTimeout(
            msg: try FfiConverterString.read(from: &buf)
            )
        case 7: return .ConnectionError(
            msg: try FfiConverterString.read(from: &buf)
            )
        case 8: return .AuthenticationError(
            msg: try FfiConverterString.read(from: &buf)
            )
        case 9: return .SessionError(
            msg: try FfiConverterString.read(from: &buf)
            )
        case 10: return .RateLimitError(
            msg: try FfiConverterString.read(from: &buf)
            )
        case 11: return .PermissionDenied(
            msg: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaykitMobileError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Transport(msg):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(msg, into: &buf)
            
        
        case let .Validation(msg):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(msg, into: &buf)
            
        
        case let .NotFound(msg):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(msg, into: &buf)
            
        
        case let .Serialization(msg):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(msg, into: &buf)
            
        
        case let .Internal(msg):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(msg, into: &buf)
            
        
        case let .NetworkTimeout(msg):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(msg, into: &buf)
            
        
        case let .ConnectionError(msg):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(msg, into: &buf)
            
        
        case let .AuthenticationError(msg):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(msg, into: &buf)
            
        
        case let .SessionError(msg):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(msg, into: &buf)
            
        
        case let .RateLimitError(msg):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(msg, into: &buf)
            
        
        case let .PermissionDenied(msg):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(msg, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaykitMobileError_lift(_ buf: RustBuffer) throws -> PaykitMobileError {
    return try FfiConverterTypePaykitMobileError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaykitMobileError_lower(_ value: PaykitMobileError) -> RustBuffer {
    return FfiConverterTypePaykitMobileError.lower(value)
}


extension PaykitMobileError: Equatable, Hashable {}




extension PaykitMobileError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Payment frequency for subscriptions.
 */

public enum PaymentFrequency {
    
    case daily
    case weekly
    case monthly(dayOfMonth: UInt8
    )
    case yearly(month: UInt8, day: UInt8
    )
    case custom(intervalSeconds: UInt64
    )
}


#if compiler(>=6)
extension PaymentFrequency: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentFrequency: FfiConverterRustBuffer {
    typealias SwiftType = PaymentFrequency

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentFrequency {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .daily
        
        case 2: return .weekly
        
        case 3: return .monthly(dayOfMonth: try FfiConverterUInt8.read(from: &buf)
        )
        
        case 4: return .yearly(month: try FfiConverterUInt8.read(from: &buf), day: try FfiConverterUInt8.read(from: &buf)
        )
        
        case 5: return .custom(intervalSeconds: try FfiConverterUInt64.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentFrequency, into buf: inout [UInt8]) {
        switch value {
        
        
        case .daily:
            writeInt(&buf, Int32(1))
        
        
        case .weekly:
            writeInt(&buf, Int32(2))
        
        
        case let .monthly(dayOfMonth):
            writeInt(&buf, Int32(3))
            FfiConverterUInt8.write(dayOfMonth, into: &buf)
            
        
        case let .yearly(month,day):
            writeInt(&buf, Int32(4))
            FfiConverterUInt8.write(month, into: &buf)
            FfiConverterUInt8.write(day, into: &buf)
            
        
        case let .custom(intervalSeconds):
            writeInt(&buf, Int32(5))
            FfiConverterUInt64.write(intervalSeconds, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentFrequency_lift(_ buf: RustBuffer) throws -> PaymentFrequency {
    return try FfiConverterTypePaymentFrequency.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentFrequency_lower(_ value: PaymentFrequency) -> RustBuffer {
    return FfiConverterTypePaymentFrequency.lower(value)
}


extension PaymentFrequency: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Payment status.
 */

public enum PaymentStatus {
    
    case pending
    case processing
    case confirmed
    case finalized
    case failed
    case cancelled
    case expired
}


#if compiler(>=6)
extension PaymentStatus: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentStatus: FfiConverterRustBuffer {
    typealias SwiftType = PaymentStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .pending
        
        case 2: return .processing
        
        case 3: return .confirmed
        
        case 4: return .finalized
        
        case 5: return .failed
        
        case 6: return .cancelled
        
        case 7: return .expired
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .pending:
            writeInt(&buf, Int32(1))
        
        
        case .processing:
            writeInt(&buf, Int32(2))
        
        
        case .confirmed:
            writeInt(&buf, Int32(3))
        
        
        case .finalized:
            writeInt(&buf, Int32(4))
        
        
        case .failed:
            writeInt(&buf, Int32(5))
        
        
        case .cancelled:
            writeInt(&buf, Int32(6))
        
        
        case .expired:
            writeInt(&buf, Int32(7))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentStatus_lift(_ buf: RustBuffer) throws -> PaymentStatus {
    return try FfiConverterTypePaymentStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentStatus_lower(_ value: PaymentStatus) -> RustBuffer {
    return FfiConverterTypePaymentStatus.lower(value)
}


extension PaymentStatus: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Payment request status.
 */

public enum RequestStatus {
    
    case pending
    case accepted
    case declined
    case expired
    case paid
}


#if compiler(>=6)
extension RequestStatus: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRequestStatus: FfiConverterRustBuffer {
    typealias SwiftType = RequestStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .pending
        
        case 2: return .accepted
        
        case 3: return .declined
        
        case 4: return .expired
        
        case 5: return .paid
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RequestStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .pending:
            writeInt(&buf, Int32(1))
        
        
        case .accepted:
            writeInt(&buf, Int32(2))
        
        
        case .declined:
            writeInt(&buf, Int32(3))
        
        
        case .expired:
            writeInt(&buf, Int32(4))
        
        
        case .paid:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRequestStatus_lift(_ buf: RustBuffer) throws -> RequestStatus {
    return try FfiConverterTypeRequestStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRequestStatus_lower(_ value: RequestStatus) -> RustBuffer {
    return FfiConverterTypeRequestStatus.lower(value)
}


extension RequestStatus: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Selection strategy.
 */

public enum SelectionStrategy {
    
    case balanced
    case costOptimized
    case speedOptimized
    case privacyOptimized
}


#if compiler(>=6)
extension SelectionStrategy: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSelectionStrategy: FfiConverterRustBuffer {
    typealias SwiftType = SelectionStrategy

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SelectionStrategy {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .balanced
        
        case 2: return .costOptimized
        
        case 3: return .speedOptimized
        
        case 4: return .privacyOptimized
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SelectionStrategy, into buf: inout [UInt8]) {
        switch value {
        
        
        case .balanced:
            writeInt(&buf, Int32(1))
        
        
        case .costOptimized:
            writeInt(&buf, Int32(2))
        
        
        case .speedOptimized:
            writeInt(&buf, Int32(3))
        
        
        case .privacyOptimized:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSelectionStrategy_lift(_ buf: RustBuffer) throws -> SelectionStrategy {
    return try FfiConverterTypeSelectionStrategy.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSelectionStrategy_lower(_ value: SelectionStrategy) -> RustBuffer {
    return FfiConverterTypeSelectionStrategy.lower(value)
}


extension SelectionStrategy: Equatable, Hashable {}







/**
 * FFI-safe storage error type.
 */
public enum StorageCacheError: Swift.Error {

    
    
    case Storage(msg: String
    )
    case Lock(msg: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeStorageCacheError: FfiConverterRustBuffer {
    typealias SwiftType = StorageCacheError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StorageCacheError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Storage(
            msg: try FfiConverterString.read(from: &buf)
            )
        case 2: return .Lock(
            msg: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: StorageCacheError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Storage(msg):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(msg, into: &buf)
            
        
        case let .Lock(msg):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(msg, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStorageCacheError_lift(_ buf: RustBuffer) throws -> StorageCacheError {
    return try FfiConverterTypeStorageCacheError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStorageCacheError_lower(_ value: StorageCacheError) -> RustBuffer {
    return FfiConverterTypeStorageCacheError.lower(value)
}


extension StorageCacheError: Equatable, Hashable {}




extension StorageCacheError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Type of scanned URI.
 */

public enum UriType {
    
    /**
     * A Pubky public key URI.
     */
    case pubky
    /**
     * An invoice URI (Lightning, Bitcoin, etc.).
     */
    case invoice
    /**
     * A payment request URI.
     */
    case paymentRequest
    /**
     * Unknown or invalid format.
     */
    case unknown
}


#if compiler(>=6)
extension UriType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUriType: FfiConverterRustBuffer {
    typealias SwiftType = UriType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UriType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .pubky
        
        case 2: return .invoice
        
        case 3: return .paymentRequest
        
        case 4: return .unknown
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: UriType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .pubky:
            writeInt(&buf, Int32(1))
        
        
        case .invoice:
            writeInt(&buf, Int32(2))
        
        
        case .paymentRequest:
            writeInt(&buf, Int32(3))
        
        
        case .unknown:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUriType_lift(_ buf: RustBuffer) throws -> UriType {
    return try FfiConverterTypeUriType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUriType_lower(_ value: UriType) -> RustBuffer {
    return FfiConverterTypeUriType.lower(value)
}


extension UriType: Equatable, Hashable {}









/**
 * Bitcoin executor callback interface for mobile wallets.
 *
 * Implement this interface in Swift/Kotlin to provide on-chain Bitcoin
 * payment capabilities to Paykit.
 *
 * # Thread Safety
 *
 * All methods may be called from any thread. Implementations must be
 * thread-safe.
 *
 * # Error Handling
 *
 * Return `PaykitMobileError` for failures. The error will be propagated
 * to the caller.
 */
public protocol BitcoinExecutorFfi: AnyObject, Sendable {
    
    /**
     * Send Bitcoin to an address.
     *
     * # Arguments
     *
     * * `address` - The destination Bitcoin address
     * * `amount_sats` - The amount to send in satoshis
     * * `fee_rate` - Optional fee rate in sat/vB (uses wallet default if None)
     *
     * # Returns
     *
     * Transaction result with txid and fee details.
     *
     * # Errors
     *
     * Returns an error if:
     * - The address is invalid
     * - Insufficient funds
     * - Network error
     * - Wallet is locked
     */
    func sendToAddress(address: String, amountSats: UInt64, feeRate: Double?) throws  -> BitcoinTxResultFfi
    
    /**
     * Estimate the fee for a transaction.
     *
     * # Arguments
     *
     * * `address` - The destination address
     * * `amount_sats` - The amount to send in satoshis
     * * `target_blocks` - Confirmation target in blocks (1, 3, 6, etc.)
     *
     * # Returns
     *
     * Estimated fee in satoshis.
     */
    func estimateFee(address: String, amountSats: UInt64, targetBlocks: UInt32) throws  -> UInt64
    
    /**
     * Get transaction details by txid.
     *
     * # Arguments
     *
     * * `txid` - The transaction ID (hex-encoded)
     *
     * # Returns
     *
     * Transaction details if found, None otherwise.
     */
    func getTransaction(txid: String) throws  -> BitcoinTxResultFfi?
    
    /**
     * Verify a transaction was sent to the expected address and amount.
     *
     * # Arguments
     *
     * * `txid` - The transaction ID
     * * `address` - Expected destination address
     * * `amount_sats` - Expected amount in satoshis
     *
     * # Returns
     *
     * True if the transaction matches, false otherwise.
     */
    func verifyTransaction(txid: String, address: String, amountSats: UInt64) throws  -> Bool
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceBitcoinExecutorFFI {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceBitcoinExecutorFfi] = [UniffiVTableCallbackInterfaceBitcoinExecutorFfi(
        sendToAddress: { (
            uniffiHandle: UInt64,
            address: RustBuffer,
            amountSats: UInt64,
            feeRate: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> BitcoinTxResultFfi in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceBitcoinExecutorFfi.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.sendToAddress(
                     address: try FfiConverterString.lift(address),
                     amountSats: try FfiConverterUInt64.lift(amountSats),
                     feeRate: try FfiConverterOptionDouble.lift(feeRate)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterTypeBitcoinTxResultFFI_lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypePaykitMobileError_lower
            )
        },
        estimateFee: { (
            uniffiHandle: UInt64,
            address: RustBuffer,
            amountSats: UInt64,
            targetBlocks: UInt32,
            uniffiOutReturn: UnsafeMutablePointer<UInt64>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> UInt64 in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceBitcoinExecutorFfi.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.estimateFee(
                     address: try FfiConverterString.lift(address),
                     amountSats: try FfiConverterUInt64.lift(amountSats),
                     targetBlocks: try FfiConverterUInt32.lift(targetBlocks)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterUInt64.lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypePaykitMobileError_lower
            )
        },
        getTransaction: { (
            uniffiHandle: UInt64,
            txid: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> BitcoinTxResultFfi? in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceBitcoinExecutorFfi.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.getTransaction(
                     txid: try FfiConverterString.lift(txid)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterOptionTypeBitcoinTxResultFFI.lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypePaykitMobileError_lower
            )
        },
        verifyTransaction: { (
            uniffiHandle: UInt64,
            txid: RustBuffer,
            address: RustBuffer,
            amountSats: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<Int8>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Bool in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceBitcoinExecutorFfi.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.verifyTransaction(
                     txid: try FfiConverterString.lift(txid),
                     address: try FfiConverterString.lift(address),
                     amountSats: try FfiConverterUInt64.lift(amountSats)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterBool.lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypePaykitMobileError_lower
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceBitcoinExecutorFfi.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface BitcoinExecutorFFI: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitBitcoinExecutorFFI() {
    uniffi_paykit_mobile_fn_init_callback_vtable_bitcoinexecutorffi(UniffiCallbackInterfaceBitcoinExecutorFFI.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceBitcoinExecutorFfi {
    fileprivate static let handleMap = UniffiHandleMap<BitcoinExecutorFfi>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceBitcoinExecutorFfi : FfiConverter {
    typealias SwiftType = BitcoinExecutorFfi
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceBitcoinExecutorFfi_lift(_ handle: UInt64) throws -> BitcoinExecutorFfi {
    return try FfiConverterCallbackInterfaceBitcoinExecutorFfi.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceBitcoinExecutorFfi_lower(_ v: BitcoinExecutorFfi) -> UInt64 {
    return FfiConverterCallbackInterfaceBitcoinExecutorFfi.lower(v)
}




/**
 * Lightning executor callback interface for mobile wallets.
 *
 * Implement this interface in Swift/Kotlin to provide Lightning Network
 * payment capabilities to Paykit.
 *
 * # Thread Safety
 *
 * All methods may be called from any thread. Implementations must be
 * thread-safe.
 *
 * # Error Handling
 *
 * Return `PaykitMobileError` for failures. The error will be propagated
 * to the caller.
 */
public protocol LightningExecutorFfi: AnyObject, Sendable {
    
    /**
     * Pay a BOLT11 invoice.
     *
     * # Arguments
     *
     * * `invoice` - The BOLT11 invoice string
     * * `amount_msat` - Optional amount in millisatoshis (for zero-amount invoices)
     * * `max_fee_msat` - Maximum fee willing to pay in millisatoshis
     *
     * # Returns
     *
     * Payment result with preimage proof.
     *
     * # Errors
     *
     * Returns an error if:
     * - Invoice is invalid or expired
     * - No route found
     * - Insufficient funds
     * - Payment failed
     */
    func payInvoice(invoice: String, amountMsat: UInt64?, maxFeeMsat: UInt64?) throws  -> LightningPaymentResultFfi
    
    /**
     * Decode a BOLT11 invoice without paying.
     *
     * # Arguments
     *
     * * `invoice` - The BOLT11 invoice string
     *
     * # Returns
     *
     * Decoded invoice details.
     */
    func decodeInvoice(invoice: String) throws  -> DecodedInvoiceFfi
    
    /**
     * Estimate the fee for paying an invoice.
     *
     * # Arguments
     *
     * * `invoice` - The BOLT11 invoice
     *
     * # Returns
     *
     * Estimated fee in millisatoshis.
     */
    func estimateFee(invoice: String) throws  -> UInt64
    
    /**
     * Check the status of a payment by payment hash.
     *
     * # Arguments
     *
     * * `payment_hash` - The payment hash (hex-encoded)
     *
     * # Returns
     *
     * Payment result if found, None otherwise.
     */
    func getPayment(paymentHash: String) throws  -> LightningPaymentResultFfi?
    
    /**
     * Verify a payment was made (check preimage matches hash).
     *
     * # Arguments
     *
     * * `preimage` - The payment preimage (hex-encoded)
     * * `payment_hash` - The payment hash (hex-encoded)
     *
     * # Returns
     *
     * True if preimage matches hash.
     */
    func verifyPreimage(preimage: String, paymentHash: String)  -> Bool
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceLightningExecutorFFI {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceLightningExecutorFfi] = [UniffiVTableCallbackInterfaceLightningExecutorFfi(
        payInvoice: { (
            uniffiHandle: UInt64,
            invoice: RustBuffer,
            amountMsat: RustBuffer,
            maxFeeMsat: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> LightningPaymentResultFfi in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceLightningExecutorFfi.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.payInvoice(
                     invoice: try FfiConverterString.lift(invoice),
                     amountMsat: try FfiConverterOptionUInt64.lift(amountMsat),
                     maxFeeMsat: try FfiConverterOptionUInt64.lift(maxFeeMsat)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterTypeLightningPaymentResultFFI_lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypePaykitMobileError_lower
            )
        },
        decodeInvoice: { (
            uniffiHandle: UInt64,
            invoice: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> DecodedInvoiceFfi in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceLightningExecutorFfi.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.decodeInvoice(
                     invoice: try FfiConverterString.lift(invoice)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterTypeDecodedInvoiceFFI_lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypePaykitMobileError_lower
            )
        },
        estimateFee: { (
            uniffiHandle: UInt64,
            invoice: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<UInt64>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> UInt64 in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceLightningExecutorFfi.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.estimateFee(
                     invoice: try FfiConverterString.lift(invoice)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterUInt64.lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypePaykitMobileError_lower
            )
        },
        getPayment: { (
            uniffiHandle: UInt64,
            paymentHash: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> LightningPaymentResultFfi? in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceLightningExecutorFfi.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.getPayment(
                     paymentHash: try FfiConverterString.lift(paymentHash)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterOptionTypeLightningPaymentResultFFI.lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypePaykitMobileError_lower
            )
        },
        verifyPreimage: { (
            uniffiHandle: UInt64,
            preimage: RustBuffer,
            paymentHash: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<Int8>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Bool in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceLightningExecutorFfi.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.verifyPreimage(
                     preimage: try FfiConverterString.lift(preimage),
                     paymentHash: try FfiConverterString.lift(paymentHash)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterBool.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceLightningExecutorFfi.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface LightningExecutorFFI: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitLightningExecutorFFI() {
    uniffi_paykit_mobile_fn_init_callback_vtable_lightningexecutorffi(UniffiCallbackInterfaceLightningExecutorFFI.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceLightningExecutorFfi {
    fileprivate static let handleMap = UniffiHandleMap<LightningExecutorFfi>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceLightningExecutorFfi : FfiConverter {
    typealias SwiftType = LightningExecutorFfi
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceLightningExecutorFfi_lift(_ handle: UInt64) throws -> LightningExecutorFfi {
    return try FfiConverterCallbackInterfaceLightningExecutorFfi.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceLightningExecutorFfi_lower(_ v: LightningExecutorFfi) -> UInt64 {
    return FfiConverterCallbackInterfaceLightningExecutorFfi.lower(v)
}




/**
 * Callback interface for authenticated Pubky storage operations.
 *
 * Mobile apps implement this to wrap their Pubky SDK session.
 * All operations are performed on the owner's storage.
 *
 * # Thread Safety
 *
 * Implementations must be thread-safe (Send + Sync).
 */
public protocol PubkyAuthenticatedStorageCallback: AnyObject, Sendable {
    
    /**
     * Put (create or update) content at the given path.
     *
     * # Arguments
     *
     * * `path` - Storage path (e.g., "/pub/paykit.app/v0/lightning")
     * * `content` - Content to store
     */
    func put(path: String, content: String)  -> StorageOperationResult
    
    /**
     * Get content at the given path.
     *
     * # Arguments
     *
     * * `path` - Storage path to read
     *
     * # Returns
     *
     * Content if found, None if path doesn't exist.
     */
    func get(path: String)  -> StorageGetResult
    
    /**
     * Delete content at the given path.
     *
     * # Arguments
     *
     * * `path` - Storage path to delete
     */
    func delete(path: String)  -> StorageOperationResult
    
    /**
     * List files with the given prefix.
     *
     * # Arguments
     *
     * * `prefix` - Path prefix to list (e.g., "/pub/paykit.app/v0/")
     */
    func list(prefix: String)  -> StorageListResult
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfacePubkyAuthenticatedStorageCallback {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfacePubkyAuthenticatedStorageCallback] = [UniffiVTableCallbackInterfacePubkyAuthenticatedStorageCallback(
        put: { (
            uniffiHandle: UInt64,
            path: RustBuffer,
            content: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> StorageOperationResult in
                guard let uniffiObj = try? FfiConverterCallbackInterfacePubkyAuthenticatedStorageCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.put(
                     path: try FfiConverterString.lift(path),
                     content: try FfiConverterString.lift(content)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterTypeStorageOperationResult_lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        get: { (
            uniffiHandle: UInt64,
            path: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> StorageGetResult in
                guard let uniffiObj = try? FfiConverterCallbackInterfacePubkyAuthenticatedStorageCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.get(
                     path: try FfiConverterString.lift(path)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterTypeStorageGetResult_lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        delete: { (
            uniffiHandle: UInt64,
            path: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> StorageOperationResult in
                guard let uniffiObj = try? FfiConverterCallbackInterfacePubkyAuthenticatedStorageCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.delete(
                     path: try FfiConverterString.lift(path)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterTypeStorageOperationResult_lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        list: { (
            uniffiHandle: UInt64,
            prefix: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> StorageListResult in
                guard let uniffiObj = try? FfiConverterCallbackInterfacePubkyAuthenticatedStorageCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.list(
                     prefix: try FfiConverterString.lift(prefix)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterTypeStorageListResult_lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfacePubkyAuthenticatedStorageCallback.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface PubkyAuthenticatedStorageCallback: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitPubkyAuthenticatedStorageCallback() {
    uniffi_paykit_mobile_fn_init_callback_vtable_pubkyauthenticatedstoragecallback(UniffiCallbackInterfacePubkyAuthenticatedStorageCallback.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfacePubkyAuthenticatedStorageCallback {
    fileprivate static let handleMap = UniffiHandleMap<PubkyAuthenticatedStorageCallback>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfacePubkyAuthenticatedStorageCallback : FfiConverter {
    typealias SwiftType = PubkyAuthenticatedStorageCallback
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfacePubkyAuthenticatedStorageCallback_lift(_ handle: UInt64) throws -> PubkyAuthenticatedStorageCallback {
    return try FfiConverterCallbackInterfacePubkyAuthenticatedStorageCallback.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfacePubkyAuthenticatedStorageCallback_lower(_ v: PubkyAuthenticatedStorageCallback) -> UInt64 {
    return FfiConverterCallbackInterfacePubkyAuthenticatedStorageCallback.lower(v)
}




/**
 * Callback interface for unauthenticated (read-only) Pubky storage operations.
 *
 * Mobile apps implement this to wrap their Pubky SDK public storage.
 *
 * # Thread Safety
 *
 * Implementations must be thread-safe (Send + Sync).
 */
public protocol PubkyUnauthenticatedStorageCallback: AnyObject, Sendable {
    
    /**
     * Get content at the given path from another user's public storage.
     *
     * # Arguments
     *
     * * `owner_pubkey` - The owner's public key (z-base32 encoded)
     * * `path` - Storage path to read
     */
    func get(ownerPubkey: String, path: String)  -> StorageGetResult
    
    /**
     * List files with the given prefix from another user's public storage.
     *
     * # Arguments
     *
     * * `owner_pubkey` - The owner's public key (z-base32 encoded)
     * * `prefix` - Path prefix to list
     */
    func list(ownerPubkey: String, prefix: String)  -> StorageListResult
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfacePubkyUnauthenticatedStorageCallback {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfacePubkyUnauthenticatedStorageCallback] = [UniffiVTableCallbackInterfacePubkyUnauthenticatedStorageCallback(
        get: { (
            uniffiHandle: UInt64,
            ownerPubkey: RustBuffer,
            path: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> StorageGetResult in
                guard let uniffiObj = try? FfiConverterCallbackInterfacePubkyUnauthenticatedStorageCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.get(
                     ownerPubkey: try FfiConverterString.lift(ownerPubkey),
                     path: try FfiConverterString.lift(path)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterTypeStorageGetResult_lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        list: { (
            uniffiHandle: UInt64,
            ownerPubkey: RustBuffer,
            prefix: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> StorageListResult in
                guard let uniffiObj = try? FfiConverterCallbackInterfacePubkyUnauthenticatedStorageCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.list(
                     ownerPubkey: try FfiConverterString.lift(ownerPubkey),
                     prefix: try FfiConverterString.lift(prefix)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterTypeStorageListResult_lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfacePubkyUnauthenticatedStorageCallback.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface PubkyUnauthenticatedStorageCallback: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitPubkyUnauthenticatedStorageCallback() {
    uniffi_paykit_mobile_fn_init_callback_vtable_pubkyunauthenticatedstoragecallback(UniffiCallbackInterfacePubkyUnauthenticatedStorageCallback.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfacePubkyUnauthenticatedStorageCallback {
    fileprivate static let handleMap = UniffiHandleMap<PubkyUnauthenticatedStorageCallback>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfacePubkyUnauthenticatedStorageCallback : FfiConverter {
    typealias SwiftType = PubkyUnauthenticatedStorageCallback
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfacePubkyUnauthenticatedStorageCallback_lift(_ handle: UInt64) throws -> PubkyUnauthenticatedStorageCallback {
    return try FfiConverterCallbackInterfacePubkyUnauthenticatedStorageCallback.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfacePubkyUnauthenticatedStorageCallback_lower(_ v: PubkyUnauthenticatedStorageCallback) -> UInt64 {
    return FfiConverterCallbackInterfacePubkyUnauthenticatedStorageCallback.lower(v)
}




/**
 * Callback interface for mobile receipt generation.
 *
 * Mobile apps implement this to generate receipts (e.g., create Lightning invoices).
 * When a payment request is received, this callback is invoked to produce
 * the final receipt with payment endpoint.
 *
 * # Example (Swift)
 *
 * ```swift
 * class MyReceiptGenerator: ReceiptGeneratorCallback {
 * func generateReceipt(request: ReceiptRequest) -> ReceiptGenerationResult {
 * // Create Lightning invoice
 * let invoice = createInvoice(amount: request.amount)
 *
 * // Update receipt with invoice in metadata
 * var receipt = request
 * receipt.metadataJson = "{\"invoice\":\"\(invoice)\"}"
 *
 * return ReceiptGenerationResult.ok(receipt: receipt)
 * }
 * }
 * ```
 */
public protocol ReceiptGeneratorCallback: AnyObject, Sendable {
    
    /**
     * Generate a receipt for a payment request.
     *
     * # Arguments
     *
     * * `request` - The provisional receipt request from the payer
     *
     * # Returns
     *
     * A `ReceiptGenerationResult` with either the finalized receipt or an error.
     */
    func generateReceipt(request: ReceiptRequest)  -> ReceiptGenerationResult
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceReceiptGeneratorCallback {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceReceiptGeneratorCallback] = [UniffiVTableCallbackInterfaceReceiptGeneratorCallback(
        generateReceipt: { (
            uniffiHandle: UInt64,
            request: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> ReceiptGenerationResult in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceReceiptGeneratorCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.generateReceipt(
                     request: try FfiConverterTypeReceiptRequest_lift(request)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterTypeReceiptGenerationResult_lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceReceiptGeneratorCallback.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface ReceiptGeneratorCallback: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitReceiptGeneratorCallback() {
    uniffi_paykit_mobile_fn_init_callback_vtable_receiptgeneratorcallback(UniffiCallbackInterfaceReceiptGeneratorCallback.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceReceiptGeneratorCallback {
    fileprivate static let handleMap = UniffiHandleMap<ReceiptGeneratorCallback>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceReceiptGeneratorCallback : FfiConverter {
    typealias SwiftType = ReceiptGeneratorCallback
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceReceiptGeneratorCallback_lift(_ handle: UInt64) throws -> ReceiptGeneratorCallback {
    return try FfiConverterCallbackInterfaceReceiptGeneratorCallback.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceReceiptGeneratorCallback_lower(_ v: ReceiptGeneratorCallback) -> UInt64 {
    return FfiConverterCallbackInterfaceReceiptGeneratorCallback.lower(v)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt16: FfiConverterRustBuffer {
    typealias SwiftType = UInt16?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt16.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt16.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionInt64: FfiConverterRustBuffer {
    typealias SwiftType = Int64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionDouble: FfiConverterRustBuffer {
    typealias SwiftType = Double?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDouble.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDouble.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeBitcoinTxResultFFI: FfiConverterRustBuffer {
    typealias SwiftType = BitcoinTxResultFfi?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeBitcoinTxResultFFI.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeBitcoinTxResultFFI.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeCachedContactFFI: FfiConverterRustBuffer {
    typealias SwiftType = CachedContactFfi?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeCachedContactFFI.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeCachedContactFFI.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeLightningPaymentResultFFI: FfiConverterRustBuffer {
    typealias SwiftType = LightningPaymentResultFfi?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLightningPaymentResultFFI.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLightningPaymentResultFFI.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeNoiseEndpointInfo: FfiConverterRustBuffer {
    typealias SwiftType = NoiseEndpointInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeNoiseEndpointInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeNoiseEndpointInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypePaymentStatusInfo: FfiConverterRustBuffer {
    typealias SwiftType = PaymentStatusInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePaymentStatusInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePaymentStatusInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypePeerSpendingLimitFFI: FfiConverterRustBuffer {
    typealias SwiftType = PeerSpendingLimitFfi?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePeerSpendingLimitFFI.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePeerSpendingLimitFFI.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypePrivateEndpointOffer: FfiConverterRustBuffer {
    typealias SwiftType = PrivateEndpointOffer?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePrivateEndpointOffer.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePrivateEndpointOffer.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeReceiptRequest: FfiConverterRustBuffer {
    typealias SwiftType = ReceiptRequest?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeReceiptRequest.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeReceiptRequest.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSelectionPreferences: FfiConverterRustBuffer {
    typealias SwiftType = SelectionPreferences?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSelectionPreferences.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSelectionPreferences.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeHealthStatus: FfiConverterRustBuffer {
    typealias SwiftType = HealthStatus?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeHealthStatus.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeHealthStatus.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeCachedContactFFI: FfiConverterRustBuffer {
    typealias SwiftType = [CachedContactFfi]

    public static func write(_ value: [CachedContactFfi], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeCachedContactFFI.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [CachedContactFfi] {
        let len: Int32 = try readInt(&buf)
        var seq = [CachedContactFfi]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeCachedContactFFI.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeHealthCheckResult: FfiConverterRustBuffer {
    typealias SwiftType = [HealthCheckResult]

    public static func write(_ value: [HealthCheckResult], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeHealthCheckResult.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [HealthCheckResult] {
        let len: Int32 = try readInt(&buf)
        var seq = [HealthCheckResult]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeHealthCheckResult.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePaymentMethod: FfiConverterRustBuffer {
    typealias SwiftType = [PaymentMethod]

    public static func write(_ value: [PaymentMethod], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePaymentMethod.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PaymentMethod] {
        let len: Int32 = try readInt(&buf)
        var seq = [PaymentMethod]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePaymentMethod.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePaymentStatusInfo: FfiConverterRustBuffer {
    typealias SwiftType = [PaymentStatusInfo]

    public static func write(_ value: [PaymentStatusInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePaymentStatusInfo.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PaymentStatusInfo] {
        let len: Int32 = try readInt(&buf)
        var seq = [PaymentStatusInfo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePaymentStatusInfo.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePeerSpendingLimitFFI: FfiConverterRustBuffer {
    typealias SwiftType = [PeerSpendingLimitFfi]

    public static func write(_ value: [PeerSpendingLimitFfi], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePeerSpendingLimitFFI.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PeerSpendingLimitFfi] {
        let len: Int32 = try readInt(&buf)
        var seq = [PeerSpendingLimitFfi]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePeerSpendingLimitFFI.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePrivateEndpointOffer: FfiConverterRustBuffer {
    typealias SwiftType = [PrivateEndpointOffer]

    public static func write(_ value: [PrivateEndpointOffer], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePrivateEndpointOffer.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PrivateEndpointOffer] {
        let len: Int32 = try readInt(&buf)
        var seq = [PrivateEndpointOffer]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePrivateEndpointOffer.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeReceiptRequest: FfiConverterRustBuffer {
    typealias SwiftType = [ReceiptRequest]

    public static func write(_ value: [ReceiptRequest], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeReceiptRequest.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ReceiptRequest] {
        let len: Int32 = try readInt(&buf)
        var seq = [ReceiptRequest]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeReceiptRequest.read(from: &buf))
        }
        return seq
    }
}
/**
 * Create a new contact cache.
 */
public func createContactCache() -> ContactCacheFfi  {
    return try!  FfiConverterTypeContactCacheFFI_lift(try! rustCall() {
    uniffi_paykit_mobile_fn_func_create_contact_cache($0
    )
})
}
/**
 * Create a new async directory operations manager.
 */
public func createDirectoryOperationsAsync()throws  -> DirectoryOperationsAsync  {
    return try  FfiConverterTypeDirectoryOperationsAsync_lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_func_create_directory_operations_async($0
    )
})
}
/**
 * Create an error message.
 *
 * # Arguments
 *
 * * `code` - Error code
 * * `message` - Error description
 */
public func createErrorMessage(code: String, message: String)throws  -> NoisePaymentMessage  {
    return try  FfiConverterTypeNoisePaymentMessage_lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_func_create_error_message(
        FfiConverterString.lower(code),
        FfiConverterString.lower(message),$0
    )
})
}
/**
 * Create a new executor async bridge.
 */
public func createExecutorAsyncBridge()throws  -> ExecutorAsyncBridge  {
    return try  FfiConverterTypeExecutorAsyncBridge_lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_func_create_executor_async_bridge($0
    )
})
}
/**
 * Create an executor async bridge with custom timeout.
 */
public func createExecutorAsyncBridgeWithTimeout(timeoutMs: UInt64)throws  -> ExecutorAsyncBridge  {
    return try  FfiConverterTypeExecutorAsyncBridge_lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_func_create_executor_async_bridge_with_timeout(
        FfiConverterUInt64.lower(timeoutMs),$0
    )
})
}
/**
 * Create a new interactive manager.
 */
public func createInteractiveManager(store: ReceiptStore) -> PaykitInteractiveManagerFfi  {
    return try!  FfiConverterTypePaykitInteractiveManagerFFI_lift(try! rustCall() {
    uniffi_paykit_mobile_fn_func_create_interactive_manager(
        FfiConverterTypeReceiptStore_lower(store),$0
    )
})
}
/**
 * Create a new message builder.
 */
public func createMessageBuilder() -> PaykitMessageBuilder  {
    return try!  FfiConverterTypePaykitMessageBuilder_lift(try! rustCall() {
    uniffi_paykit_mobile_fn_func_create_message_builder($0
    )
})
}
/**
 * Create a default noise server configuration.
 */
public func createNoiseServerConfig() -> NoiseServerConfig  {
    return try!  FfiConverterTypeNoiseServerConfig_lift(try! rustCall() {
    uniffi_paykit_mobile_fn_func_create_noise_server_config($0
    )
})
}
/**
 * Create a noise server configuration with a specific port.
 */
public func createNoiseServerConfigWithPort(port: UInt16) -> NoiseServerConfig  {
    return try!  FfiConverterTypeNoiseServerConfig_lift(try! rustCall() {
    uniffi_paykit_mobile_fn_func_create_noise_server_config_with_port(
        FfiConverterUInt16.lower(port),$0
    )
})
}
/**
 * Create a new Paykit client.
 */
public func createPaykitClient()throws  -> PaykitClient  {
    return try  FfiConverterTypePaykitClient_lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_func_create_paykit_client($0
    )
})
}
/**
 * Create a private endpoint offer message.
 *
 * # Arguments
 *
 * * `method_id` - Payment method identifier
 * * `endpoint` - The private endpoint data
 * * `expires_in_secs` - Optional expiration time in seconds
 */
public func createPrivateEndpointOfferMessage(methodId: String, endpoint: String, expiresInSecs: UInt64?)throws  -> NoisePaymentMessage  {
    return try  FfiConverterTypeNoisePaymentMessage_lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_func_create_private_endpoint_offer_message(
        FfiConverterString.lower(methodId),
        FfiConverterString.lower(endpoint),
        FfiConverterOptionUInt64.lower(expiresInSecs),$0
    )
})
}
/**
 * Create a receipt confirmation message.
 *
 * # Arguments
 *
 * * `receipt_id` - The receipt ID being confirmed
 * * `payer_pubkey` - Payer's public key
 * * `payee_pubkey` - Payee's public key
 * * `method_id` - Payment method used
 * * `amount` - Payment amount
 * * `currency` - Currency code
 * * `signature` - Optional signature from payee
 */
public func createReceiptConfirmationMessage(receiptId: String, payerPubkey: String, payeePubkey: String, methodId: String, amount: String?, currency: String?, signature: String?)throws  -> NoisePaymentMessage  {
    return try  FfiConverterTypeNoisePaymentMessage_lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_func_create_receipt_confirmation_message(
        FfiConverterString.lower(receiptId),
        FfiConverterString.lower(payerPubkey),
        FfiConverterString.lower(payeePubkey),
        FfiConverterString.lower(methodId),
        FfiConverterOptionString.lower(amount),
        FfiConverterOptionString.lower(currency),
        FfiConverterOptionString.lower(signature),$0
    )
})
}
/**
 * Create a receipt request message.
 *
 * # Arguments
 *
 * * `receipt_id` - Unique identifier for this receipt
 * * `payer_pubkey` - Payer's public key (z-base32)
 * * `payee_pubkey` - Payee's public key (z-base32)
 * * `method_id` - Payment method identifier
 * * `amount` - Optional payment amount
 * * `currency` - Optional currency code
 */
public func createReceiptRequestMessage(receiptId: String, payerPubkey: String, payeePubkey: String, methodId: String, amount: String?, currency: String?)throws  -> NoisePaymentMessage  {
    return try  FfiConverterTypeNoisePaymentMessage_lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_func_create_receipt_request_message(
        FfiConverterString.lower(receiptId),
        FfiConverterString.lower(payerPubkey),
        FfiConverterString.lower(payeePubkey),
        FfiConverterString.lower(methodId),
        FfiConverterOptionString.lower(amount),
        FfiConverterOptionString.lower(currency),$0
    )
})
}
/**
 * Create a new receipt store.
 */
public func createReceiptStore() -> ReceiptStore  {
    return try!  FfiConverterTypeReceiptStore_lift(try! rustCall() {
    uniffi_paykit_mobile_fn_func_create_receipt_store($0
    )
})
}
/**
 * Create a new spending manager.
 *
 * # Arguments
 *
 * * `storage_path` - Path to the storage directory
 */
public func createSpendingManager(storagePath: String)throws  -> SpendingManagerFfi  {
    return try  FfiConverterTypeSpendingManagerFFI_lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_func_create_spending_manager(
        FfiConverterString.lower(storagePath),$0
    )
})
}
/**
 * Derive X25519 keypair for Noise protocol from Ed25519 seed.
 *
 * This uses the pubky-noise KDF to derive device-specific encryption keys
 * from the Ed25519 identity seed.
 *
 * # Arguments
 *
 * * `ed25519_secret_hex` - The Ed25519 secret key (seed) in hex format.
 * * `device_id` - A unique identifier for this device.
 * * `epoch` - Key rotation epoch (increment to rotate keys).
 *
 * # Returns
 *
 * The derived X25519 keypair for use with Noise protocol.
 */
public func deriveX25519Keypair(ed25519SecretHex: String, deviceId: String, epoch: UInt32)throws  -> X25519Keypair  {
    return try  FfiConverterTypeX25519Keypair_lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_func_derive_x25519_keypair(
        FfiConverterString.lower(ed25519SecretHex),
        FfiConverterString.lower(deviceId),
        FfiConverterUInt32.lower(epoch),$0
    )
})
}
/**
 * Discover a Noise endpoint for a recipient.
 *
 * Queries the recipient's public directory for their Noise server information.
 *
 * # Arguments
 *
 * * `transport` - Unauthenticated transport for reading
 * * `recipient_pubkey` - The recipient's public key (z-base32 encoded)
 *
 * # Returns
 *
 * The noise endpoint info if found, None otherwise.
 *
 * # Example
 *
 * ```ignore
 * let transport = UnauthenticatedTransportFFI::new_mock();
 * if let Some(endpoint) = discover_noise_endpoint(&transport, "8pinxxgqs41...")? {
 * println!("Connecting to {}:{}", endpoint.host, endpoint.port);
 * println!("Server pubkey: {}", endpoint.server_noise_pubkey);
 * }
 * ```
 */
public func discoverNoiseEndpoint(transport: UnauthenticatedTransportFfi, recipientPubkey: String)throws  -> NoiseEndpointInfo?  {
    return try  FfiConverterOptionTypeNoiseEndpointInfo.lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_func_discover_noise_endpoint(
        FfiConverterTypeUnauthenticatedTransportFFI_lower(transport),
        FfiConverterString.lower(recipientPubkey),$0
    )
})
}
/**
 * Derive Ed25519 public key from secret key.
 *
 * # Arguments
 *
 * * `secret_key_hex` - The 32-byte secret key in hex format.
 *
 * # Returns
 *
 * The complete keypair derived from the secret.
 */
public func ed25519KeypairFromSecret(secretKeyHex: String)throws  -> Ed25519Keypair  {
    return try  FfiConverterTypeEd25519Keypair_lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_func_ed25519_keypair_from_secret(
        FfiConverterString.lower(secretKeyHex),$0
    )
})
}
/**
 * Export keypair to encrypted backup.
 *
 * # Arguments
 *
 * * `secret_key_hex` - The secret key to backup.
 * * `password` - Password to encrypt the backup.
 *
 * # Returns
 *
 * Encrypted backup that can be stored or transferred.
 */
public func exportKeypairToBackup(secretKeyHex: String, password: String)throws  -> KeyBackup  {
    return try  FfiConverterTypeKeyBackup_lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_func_export_keypair_to_backup(
        FfiConverterString.lower(secretKeyHex),
        FfiConverterString.lower(password),$0
    )
})
}
/**
 * Format public key as z-base32 (pkarr format).
 */
public func formatPublicKeyZ32(publicKeyHex: String)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_func_format_public_key_z32(
        FfiConverterString.lower(publicKeyHex),$0
    )
})
}
/**
 * Get the unique device ID for this device.
 *
 * This should be stored persistently and reused for consistent key derivation.
 * If not available, generates a new random device ID.
 */
public func generateDeviceId() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_paykit_mobile_fn_func_generate_device_id($0
    )
})
}
/**
 * Generate a new Ed25519 keypair for identity.
 *
 * This creates a new random identity. The secret key should be stored
 * securely and backed up.
 *
 * # Returns
 *
 * A new Ed25519 keypair with the secret in hex format.
 */
public func generateEd25519Keypair()throws  -> Ed25519Keypair  {
    return try  FfiConverterTypeEd25519Keypair_lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_func_generate_ed25519_keypair($0
    )
})
}
/**
 * Get the library version.
 */
public func getVersion() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_paykit_mobile_fn_func_get_version($0
    )
})
}
/**
 * Import keypair from encrypted backup.
 *
 * # Arguments
 *
 * * `backup` - The encrypted backup.
 * * `password` - Password to decrypt the backup.
 *
 * # Returns
 *
 * The decrypted keypair.
 */
public func importKeypairFromBackup(backup: KeyBackup, password: String)throws  -> Ed25519Keypair  {
    return try  FfiConverterTypeEd25519Keypair_lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_func_import_keypair_from_backup(
        FfiConverterTypeKeyBackup_lower(backup),
        FfiConverterString.lower(password),$0
    )
})
}
/**
 * Parse a payment message from JSON.
 *
 * # Arguments
 *
 * * `json` - The JSON string to parse
 */
public func parsePaymentMessage(json: String)throws  -> NoisePaymentMessage  {
    return try  FfiConverterTypeNoisePaymentMessage_lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_func_parse_payment_message(
        FfiConverterString.lower(json),$0
    )
})
}
/**
 * Parse z-base32 public key to hex.
 */
public func parsePublicKeyZ32(publicKeyZ32: String)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_func_parse_public_key_z32(
        FfiConverterString.lower(publicKeyZ32),$0
    )
})
}
/**
 * Publish a Noise endpoint to the directory.
 *
 * Makes this device discoverable for receiving payments via Noise protocol.
 *
 * # Arguments
 *
 * * `transport` - Authenticated transport for writing
 * * `host` - Host address where the Noise server is listening
 * * `port` - Port number where the Noise server is listening
 * * `noise_pubkey` - This server's Noise public key (X25519, hex encoded)
 * * `metadata` - Optional metadata about the endpoint
 */
public func publishNoiseEndpoint(transport: AuthenticatedTransportFfi, host: String, port: UInt16, noisePubkey: String, metadata: String?)throws   {try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_func_publish_noise_endpoint(
        FfiConverterTypeAuthenticatedTransportFFI_lower(transport),
        FfiConverterString.lower(host),
        FfiConverterUInt16.lower(port),
        FfiConverterString.lower(noisePubkey),
        FfiConverterOptionString.lower(metadata),$0
    )
}
}
/**
 * Remove the Noise endpoint from the directory.
 *
 * Makes this device no longer discoverable for Noise payments.
 *
 * # Arguments
 *
 * * `transport` - Authenticated transport for writing
 */
public func removeNoiseEndpoint(transport: AuthenticatedTransportFfi)throws   {try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_func_remove_noise_endpoint(
        FfiConverterTypeAuthenticatedTransportFFI_lower(transport),$0
    )
}
}
/**
 * Sign a message with Ed25519 secret key.
 *
 * # Arguments
 *
 * * `secret_key_hex` - The Ed25519 secret key in hex format.
 * * `message` - The message bytes to sign.
 *
 * # Returns
 *
 * The 64-byte signature in hex format.
 */
public func signMessage(secretKeyHex: String, message: Data)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_func_sign_message(
        FfiConverterString.lower(secretKeyHex),
        FfiConverterData.lower(message),$0
    )
})
}
/**
 * Verify an Ed25519 signature.
 *
 * # Arguments
 *
 * * `public_key_hex` - The Ed25519 public key in hex format.
 * * `message` - The original message bytes.
 * * `signature_hex` - The 64-byte signature in hex format.
 *
 * # Returns
 *
 * True if the signature is valid, false otherwise.
 */
public func verifySignature(publicKeyHex: String, message: Data, signatureHex: String)throws  -> Bool  {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypePaykitMobileError_lift) {
    uniffi_paykit_mobile_fn_func_verify_signature(
        FfiConverterString.lower(publicKeyHex),
        FfiConverterData.lower(message),
        FfiConverterString.lower(signatureHex),$0
    )
})
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private let initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 29
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_paykit_mobile_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_create_contact_cache() != 8922) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_create_directory_operations_async() != 3774) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_create_error_message() != 3910) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_create_executor_async_bridge() != 20970) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_create_executor_async_bridge_with_timeout() != 64108) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_create_interactive_manager() != 29264) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_create_message_builder() != 17772) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_create_noise_server_config() != 51894) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_create_noise_server_config_with_port() != 20409) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_create_paykit_client() != 24343) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_create_private_endpoint_offer_message() != 39588) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_create_receipt_confirmation_message() != 60309) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_create_receipt_request_message() != 237) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_create_receipt_store() != 25695) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_create_spending_manager() != 50773) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_derive_x25519_keypair() != 88) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_discover_noise_endpoint() != 25103) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_ed25519_keypair_from_secret() != 6399) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_export_keypair_to_backup() != 9110) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_format_public_key_z32() != 40068) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_generate_device_id() != 4216) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_generate_ed25519_keypair() != 1379) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_get_version() != 23495) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_import_keypair_from_backup() != 19578) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_parse_payment_message() != 29256) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_parse_public_key_z32() != 22606) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_publish_noise_endpoint() != 19637) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_remove_noise_endpoint() != 4253) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_sign_message() != 33882) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_func_verify_signature() != 15460) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_authenticatedtransportffi_delete() != 27910) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_authenticatedtransportffi_get() != 62854) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_authenticatedtransportffi_is_mock() != 21711) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_authenticatedtransportffi_list() != 35643) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_authenticatedtransportffi_owner_pubkey() != 20095) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_authenticatedtransportffi_put() != 38814) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_contactcacheffi_add() != 92) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_contactcacheffi_add_with_name() != 4648) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_contactcacheffi_clear() != 8267) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_contactcacheffi_contains() != 34921) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_contactcacheffi_count() != 63824) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_contactcacheffi_get() != 46556) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_contactcacheffi_get_all() != 31771) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_contactcacheffi_remove() != 38239) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_contactcacheffi_sync() != 18218) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_directoryoperationsasync_add_contact() != 64657) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_directoryoperationsasync_fetch_known_contacts() != 25738) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_directoryoperationsasync_fetch_payment_endpoint() != 33741) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_directoryoperationsasync_fetch_supported_payments() != 29833) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_directoryoperationsasync_list_contacts() != 14459) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_directoryoperationsasync_publish_payment_endpoint() != 28899) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_directoryoperationsasync_remove_contact() != 59089) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_directoryoperationsasync_remove_payment_endpoint() != 29515) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_executorasyncbridge_default_timeout_ms() != 61076) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_add_contact() != 27458) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_bitcoin_network() != 27708) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_calculate_proration() != 24209) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_check_health() != 61124) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_create_noise_error_message() != 18706) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_create_payment_request() != 15935) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_create_receipt() != 56818) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_create_receipt_confirmation_message() != 6664) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_create_receipt_request_message() != 18369) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_create_subscription() != 64542) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_days_remaining_in_period() != 16529) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_discover_noise_endpoint() != 30069) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_execute_payment() != 54016) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_extract_key_from_qr() != 58479) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_extract_method_from_qr() != 37762) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_fetch_known_contacts() != 7044) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_fetch_payment_endpoint() != 23881) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_fetch_supported_payments() != 64176) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_generate_payment_proof() != 22627) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_get_health_status() != 18007) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_get_in_progress_payments() != 25824) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_get_payment_status() != 45141) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_has_bitcoin_executor() != 26726) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_has_lightning_executor() != 9374) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_is_method_usable() != 42161) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_is_paykit_qr() != 16545) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_lightning_network() != 43080) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_list_contacts() != 10137) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_list_methods() != 42624) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_parse_noise_payment_message() != 32861) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_parse_receipt_metadata() != 40279) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_parse_scanned_qr() != 33898) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_publish_noise_endpoint() != 41601) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_publish_payment_endpoint() != 60780) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_register_bitcoin_executor() != 59174) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_register_lightning_executor() != 31839) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_remove_contact() != 19687) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_remove_noise_endpoint() != 62949) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_remove_payment_endpoint_from_directory() != 16146) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_select_method() != 59923) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitclient_validate_endpoint() != 33544) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_create_endpoint_offer() != 7132) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_create_payment_request() != 40014) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_get_private_endpoint() != 11512) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_get_receipt() != 23046) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_get_store() != 2983) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_handle_message() != 1743) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_handle_payment_response() != 48896) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_list_private_endpoints() != 31358) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_list_receipts() != 20652) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitinteractivemanagerffi_set_generator() != 13757) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitmessagebuilder_create_ack() != 36644) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitmessagebuilder_create_endpoint_offer() != 51224) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitmessagebuilder_create_error() != 54428) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitmessagebuilder_create_receipt_confirm() != 17217) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitmessagebuilder_create_receipt_request() != 1989) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitmessagebuilder_get_message_type() != 64569) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_paykitmessagebuilder_parse_message() != 34318) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_receiptstore_clear() != 37348) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_receiptstore_delete_receipt() != 25391) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_receiptstore_export_receipts_json() != 57252) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_receiptstore_get_private_endpoint() != 26455) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_receiptstore_get_receipt() != 44214) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_receiptstore_import_receipts_json() != 7286) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_receiptstore_list_private_endpoints() != 39184) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_receiptstore_list_receipts() != 50608) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_receiptstore_save_private_endpoint() != 15942) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_receiptstore_save_receipt() != 8333) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_spendingmanagerffi_active_reservations_count() != 55714) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_spendingmanagerffi_commit_spending() != 13846) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_spendingmanagerffi_get_peer_spending_limit() != 5613) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_spendingmanagerffi_list_spending_limits() != 65228) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_spendingmanagerffi_remove_peer_spending_limit() != 47647) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_spendingmanagerffi_rollback_spending() != 34174) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_spendingmanagerffi_set_peer_spending_limit() != 27818) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_spendingmanagerffi_try_reserve_spending() != 12692) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_spendingmanagerffi_would_exceed_spending_limit() != 55448) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_unauthenticatedtransportffi_get() != 49528) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_unauthenticatedtransportffi_is_mock() != 10080) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_unauthenticatedtransportffi_list() != 22800) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_constructor_authenticatedtransportffi_from_callback() != 43440) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_constructor_authenticatedtransportffi_from_session_json() != 62420) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_constructor_authenticatedtransportffi_new_mock() != 11731) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_constructor_contactcacheffi_new() != 57738) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_constructor_directoryoperationsasync_new() != 16025) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_constructor_executorasyncbridge_new() != 15857) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_constructor_executorasyncbridge_with_timeout() != 10677) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_constructor_paykitclient_new() != 40436) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_constructor_paykitclient_new_with_network() != 21874) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_constructor_paykitinteractivemanagerffi_new() != 49533) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_constructor_paykitmessagebuilder_new() != 35980) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_constructor_receiptstore_new() != 15932) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_constructor_spendingmanagerffi_new() != 42030) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_constructor_unauthenticatedtransportffi_from_authenticated() != 32228) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_constructor_unauthenticatedtransportffi_from_callback() != 39502) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_constructor_unauthenticatedtransportffi_from_config_json() != 20872) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_constructor_unauthenticatedtransportffi_new_mock() != 6380) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_bitcoinexecutorffi_send_to_address() != 10733) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_bitcoinexecutorffi_estimate_fee() != 51016) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_bitcoinexecutorffi_get_transaction() != 58497) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_bitcoinexecutorffi_verify_transaction() != 45133) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_lightningexecutorffi_pay_invoice() != 31716) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_lightningexecutorffi_decode_invoice() != 42989) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_lightningexecutorffi_estimate_fee() != 11875) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_lightningexecutorffi_get_payment() != 54276) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_lightningexecutorffi_verify_preimage() != 46457) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_pubkyauthenticatedstoragecallback_put() != 27074) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_pubkyauthenticatedstoragecallback_get() != 45248) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_pubkyauthenticatedstoragecallback_delete() != 26277) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_pubkyauthenticatedstoragecallback_list() != 49068) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_pubkyunauthenticatedstoragecallback_get() != 47092) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_pubkyunauthenticatedstoragecallback_list() != 31988) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_paykit_mobile_checksum_method_receiptgeneratorcallback_generate_receipt() != 60095) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitBitcoinExecutorFFI()
    uniffiCallbackInitLightningExecutorFFI()
    uniffiCallbackInitPubkyAuthenticatedStorageCallback()
    uniffiCallbackInitPubkyUnauthenticatedStorageCallback()
    uniffiCallbackInitReceiptGeneratorCallback()
    return InitializationResult.ok
}()

// Make the ensure init function public so that other modules which have external type references to
// our types can call it.
public func uniffiEnsurePaykitMobileInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all